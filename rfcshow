#!/bin/bash
# vim: tw=0: ww=0:
# Copyright (C) 2005 Eric Gillespie
# Copyright under the GNU Public License Version 2
Revision=43
Minor=0.9

# ZD: -- for long, - for short, the other way around is annoying
# ZD: The indenting is making the code hard to read
# Reformatted. See?

######################### Requirements #############################
# ncftp, bash, expect (not mandatory, but it needs tcl installed), 
# b(un)zip2, g(un)zip, bzgrep, zgrep, grep, cut, cat, sort (?)
# and perl (this'll possibly change to sed)
######################### Requirements #############################
######################### Instructions #############################

# * Change the hashbang line to reflect where your copy of bash lives
# *  First off, make sure that you have a set of docs to view.
#    If you don't, the script can go and get them, but you still
#    have to consider the next point.
# *  Next, make sure they're in a directory you have permission to
#    read. Write permission would also be nice, but isn't mandatory.
#    If you don't have a writable dir, the program will ask you if 
#    you want to create one under your home directory.
# *  Enter the following into a shell:

#          rfcshow --get -ref --get -index --get xx00

#    This will get the cross references file, the index, and titles.
# *  After this, run the program as normal.
#    rfc -help will get you some help to describe the options.

# This could replace the perl script
# sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;/BBB/!d;/CCC/!d' 
# ... where AAA, BBB, and CCC are terms we hunt for. I'll probably
# try to use it just with AAA, and implement it like this:
# $ST (searchterm) = $1; cat $RFC | sed -e '/./{H;$!d;}' -e 'x;/'"$ST"'!d' > $MYFILE
#
# Multiple terms could WELL be used with this.

######################### Instructions #############################

ME="$(basename $0)"
TITLE="$Minor.$Revision Supplied RFCs"
# Filename to retrieve rfc titles from
TITLES=-ref
# This place for Debian
#PLACE=/usr/share/doc/RFC/links
# This place, for my system.
#PLACE=/usr/share/doc/rfc
# We'll check Debian first, followed by my standard places
# Only time this doesn't work is if you have a $HOME/rfc that's a file, 
# and not a dir. Then, if none of the others exist, we're in trouble
PLACES="/usr/share/doc/RFC/links/ /usr/share/doc/rfc/ $HOME/rfc/"
# This MUST be a directory you have write access to, with enough room for say, 1Mb
MYDIR=/tmp
# You COULD put it into your own dir, but then we'd have to create it if it didn't
# already exist.
WHORANME=$(whoami)
STATUSFILE=$MYDIR/rfcstatus.$WHORANME.log
MYFILE=$MYDIR/rfctemprfc.$WHORANME.$$.$RANDOM
MYFILE2=$MYDIR/rfctempoutput
# Do we want the web site, or the ftp site? http would have to mean using wget/curl/lynx
# with all the complications that would provide
REMOTEPLACE="ftp://ftp.rfc-editor.org/in-notes/"
REMOTEPDFPLACE="ftp://ftp.rfc-editor.org/in-notes/pdfrfc/"
REMOTEWEBPLACE="http://www.rfc-editor.org/"
# Extensions here, now all I need to do is to hack in handlers for them all.
TXTEXT=txt
PDFEXT=pdf
PSEXT=ps
TAREXT=tar
GZEXT=gz
BZ2EXT=bz2
# Now we generate a time ready for offset.
MYTIMESTART=$(date +%s)
# Gee, what happens if we have NONE of these? wow...
# Suggested by LennonNZ - thanks. This was for Debian boxes that don't get bzip2 tools
# installed by default.
# ZD: these whiches could be replaced by types instead, as type is a builtin
MYGUNZIP=$(type -p gunzip 2>/dev/null)
MYBUNZIP=$(type -p bunzip2 2>/dev/null)
# We prefer bzip2 over gzip
MYUNCOMPRESS=${MYBUNZIP:-$MYGUNZIP}
MYGZIP=$(type -p gzip 2>/dev/null)
MYBZIP=$(type -p bzip2 2>/dev/null)
MYCOMPRESS=${MYBZIP:-$MYGZIP}
# What if we don't even have a zgrep? Make one up, like bzgrep() ?
MYZGREP=$(type -p zgrep 2>/dev/null)
# This is a little problematic for older FreeBSD systems (4.x) as
# they never had a bzgrep in their bzip2 package. It's only recent.
# So we have the aspect of: we can create bzip2 content, but we can't bzgrep it
MYBZGREP=$(type -p bzgrep 2>/dev/null)
# Now I have a problem - I'm using hardcoded programs to (uncompress and) grep.
MYCGREP=${MYBZGREP:-$MYZGREP}
MYGREP=$(type -p grep 2>/dev/null)
if [ -z "$MYBZGREP" ]; then
  GREPALIAS=1
# Had to hack one in, as one wasn't found on the machine.
# This is a VERY simple version, and as such, has some limitations
# like: only one search term, without spaces
    bzgrep() {
        this="$1"
        that="$2"
        bzcat "$that" | grep "$this"
    }
    MYBZGREP=bzgrep
fi

if [ -z "$MYZGREP" ]; then
  GREPALIAS=2
# Had to hack one in, as one wasn't found on the machine.
# This is a VERY simple version, and as such, has some limitations
# like: only one search term, without spaces
    zgrep() {
        this="$1"
        that="$2"
        zcat "$that" | grep "$this"
    }
    MYZGREP=zgrep
fi
# Now we'd better rejigger MYCGREP
if [ "$GREPALIAS" ]; then
  case $GREPALIAS in
    1)
    MYCGREP=$MYBZGREP
    ;;
    2)
    MYCGREP=$MYZGREP
    ;;
  esac
fi

# better put one in here, sure as eggs SOMEONE will want it
DEFEXT=$TXTEXT
FORMAT=rfc
###### we intend to change it with command switches, otherwise it'll remain as .txt
# locally stored list of remote files at $REMOTEHOST, this will have $FORMAT glued on the front
DIRLIST=-list.txt
RFC_FILE1=rfc-index.txt
RFC_FILE2=rfc-ref.txt 
RFC_FILE3=rfcxx00.txt
#CONTACT_TIMEOUT=40
CONTACT_TIMEOUT=60
# Here, we choose which getting mechanism we want. I use ncftpget, but others
# can be set up, such as lynx, wget, or curl.
# Here's options for href, as an example
# lynx -dump http://www.rfc-editor.org/cgi-bin/rfcdoctype.pl?loc=RFC\&letsgo=822\&type=ftp\&file_format=txt
# Why don't we ask the user which one they want of the ones we've found? 
# $MyDialog --title "$ME: query" --radio ...
MYNCGET=$(type -p ncftpget 2>/dev/null)
MYNCLS=$( type -p ncftpls 2>/dev/null)
MYLYNX=$(type -p lynx 2>/dev/null)
MYWGET=$(type -p wget 2>/dev/null)
MYCURL=$(type -p curl 2>/dev/null)
# Now, it's time to select something to fetch with
# We really DON'T want to use ftp unless we absolutely HAVE to
# For the moment, until I unwire the logic, I'm selecting ncftpget
# but it'll be replaced by the third line below
MYT1=${MYCURL:-$MYNCGET}
#MYT2=${MYWGET:-$MYLYNX}
MYGET=${MYT1:-$MYT2}
case $MYGET in
    $MYNCGET)
    # We should probably add in MYNCLS here
        MYGETPARM=" -v "
        MYLSPARM=" -1 "
    # Should we also customise return errors in here?
        ;;
    $MYLYNX)
        MYGETPARM=" -dump "
# Hrm. No MYLSPARM for lynx - better make one up.
        MYLSPARM=" -dump "
        ;;
    $MYWGET)
    # Wget downloads the whole directory listing when retrieving
    # a ftp document... We want wget to be totally quiet but this won't prevent
    # it from downloading a dir listing.
        MYGETPARM=" -q "
        ;;
    $MYCURL)
    # We want curl to be totally quiet
        MYGETPARM=" -so "
        MYLSPARM=" -sI "
        MYDIRPARM=" -sl "
# Interesting. Curl can give me the file size of a specific file, just by using -I.
# Could be a way of losing the expect script and dep;  the only problem then being
# that we _require_ curl
        ;;
    *)
        echo "Whoops - shouldn't have got here: got $MYGET - hit enter to continue"
        read mumble
        ;;
esac

TitleNotify="$ME-$Minor.$Revision: notify"
TitleError="$ME-$Minor.$Revision: error"

############################################################
# Now we start in on the functions, and pick up on the rest
# after all the functions are defined.
############################################################

############################################################################################
# A resizing function to be called when SIGWINCH is picked up
# by the shell. This needs to be called from trap:  trap ReSize SIGWINCH
############################################################################################

ReSize() {
    MYSIZE=$(stty size)
# MYX and MYY and MYLINES all need changing...
    MYY=${MYSIZE% *}
    MYX=$(( ${MYSIZE##* } - 2 ))
    MYX=$( echo $(($MYX - 2 )) )
    if [ $MYX -gt 78 ]; then
        MYLISTX=78
    else
        MYLISTX=$MYX
    fi
    MYLINES=$MYY
}

##################################################################
# A utility routine, called from StartMeUp()
##################################################################
GaugeCount() {
  # Found one error with this; if MAXVAL is 0 or undefined, we're dead.
	if [ $qui == $1 ]; then
		echo "100";  echo "XXX"; echo "Percentage: $qui"; echo "XXX"
	else
		echo "$(($qui*10000/$1))"; echo "XXX"; echo "Percentage: $(($qui*10000/$1))"; echo "XXX"
	fi
}


# This is in here to provide a progress meter as I start up.
StartMeUp() {
##################################################################
#
# This routine opens up the data file, stuffs it into my arrays
#
##################################################################
	qui=0
		case $OSTYPE in
		linux*)
		case $MyDialog in "$MYKDIALOG")
			$MyDialog --title "$ME" --msgbox "Processing - please wait"
			sleep 2
			;;
						*)
			for this in $(seq 0 100 $1); do
				qui=$(( qui + 1 ))
				echo $qui | GaugeCount $1
			done | $MyDialog --title "$ME" --gauge "Starting up" 6 "$MYX" 0
		esac
		;;
		freebsd*)
			$MyDialog --title "$ME" --infobox "Processing data file - please wait" 3 40
			sleep 2
		;;
		esac
  # we need some way of feeding a progress meter with dialog.
}

Format() {
  # Here we choose whether to get/use rfc,bcp,fyi or std documents
  FormatArray=( "bcp" "Best common practices" "off" "fyi" "For Your Information" "off" "rfc" "Requests For Comments" "on" "std" "Standards" "off" )
  FORMAT=$( $MyDialog --title "Choose format" --radiolist "Please choose format" 12 40 5 "${FormatArray[@]}" 2>&1 >$(tty))
  retval=$?
  case $retval in 
    1)
    echo "Sorry, dumping"
    exit
    ;;
    0)
    # Here, we only alter FORMAT if it's NOT rfc.
    case $FORMAT in 
      bcp) HEREPLACE="$PLACE$FORMAT/"
      THEREPLACE="$REMOTEPLACE$FORMAT/"
      MYMAXVAL=$MAXBCPVAL
      ;;
      fyi) HEREPLACE="$PLACE$FORMAT/"
      THEREPLACE="$REMOTEPLACE$FORMAT/"
      MYMAXVAL=$MAXFYIVAL
      ;;
      std) HEREPLACE="$PLACE$FORMAT/"
      THEREPLACE="$REMOTEPLACE$FORMAT/"
      MYMAXVAL=$MAXSTDVAL
      ;;
      *) HEREPLACE="$PLACE" 
      THEREPLACE="$REMOTEPLACE"
      MYMAXVAL=$MAXVAL
      ;;
    esac
    ;;
  esac
}

MyNotify() {
# Small number of lines of message text
  Value=$($MyDialog --title "$TitleNotify" --msgbox "$@" $MYLINES $MYMINX 2>&1 >&$(tty))
  retval=$?
}

MyError() {
# Small number of lines of error message text
  Value=$($MyDialog --title "$TitleError" --msgbox "$@" $MYLINES $MYMINX 2>&1 >&$(tty))
  retval=$?
}

MyStatus()  {
# Time in seconds after epoch
  MyTime=$(date +%s)
  # I've taken this off the start time so I get a difference in seconds, instead of an
  # absolute timestamp. Seems more "real world" to me, what people expect. Least surprise.
  echo "+$(( $MyTime - $MYTIMESTART )): $@" >> $STATUSFILE
}

MyText() {
  Value=$($MyDialog --title "$TitleNotify" --textbox "$MYFILE" $MYLINES $MYMINX 2>&1 >&$(tty))
}

seq() {
############################################################################################
#
# Subroutine to handle the command differences between FreeBSD's jot and Linux's seq program.
#
############################################################################################
    seqplace=$(which seq)
    case $OSTYPE in 
        freebsd*)
# jot needs to have the count of values as the iterate, not the maxval
            jot $(($3 + 1 )) $1 $3 $2 ;;
        *) $seqplace $1 $2 $3 ;;
    esac
}

DeadYet() {
# Utility function
    if [ $retval -gt 0 ]; then
        menulevel=0  
    fi
}

HelpDeadYet() {
# Utility function
    if [ $retval -gt 0 ]; then
        noexit=0  
    fi
}

TestItsHere() {
# This routine tests (1) is the file here? Returns three vars: NOTHERE, HERE and mumble
    NOTHERE=1
# Got to get this bit right
    mumble=$(ls ${HEREPLACE}${REMOTEFILE}.* 2>/dev/null )
#    echo "We got $mumble"
#    read munch
    if [ "$mumble" ]; then
        HERE=$HEREPLACE
        NOTHERE=0
    fi
}

############################################
# Engine code
############################################
RfcEngine() {
  MyStatus "Entering RfcEngine with X: $MYX; Y: $MYY; L: $MYLINES MLX: $MYLISTX File: $Q Val:$Val R: $RFCFile. DIALOG=$MyDialog"
    if [ "$STDOUT" ]; then
# Used for the -stdout switch
        cat $MYFILE
    else
          # Suggested by LennonNZ#nzlinux noting whiptail didn't scroll textboxes
        case $MyDialog in
            $MyWHIPTAIL)
            # Line to tell the user to wait, as whiptail takes time on a big file.
                $MyDialog --title "$ME-$Minor.$Revision: Info" --infobox "Please wait while I display file" 11 50
                sleep 2
                echo "rendering $MYFILE to screen with $MYLINES lines and $MYLISTX wide"
                read mumble
                $MyDialog --title "$ME-$Minor.$Revision: Supplied RFCs" --scrolltext --textbox $MYFILE "$MYLINES" "$MYLISTX"
                sleep 5
                ;;
             $MyKDialog)
             MYLINES=11
            # Line to tell the user to wait, as kdialog takes time on a big file.
             MyNotify "Please click OK, then wait while I display file"
#             $MyDialog --title "$ME-$Minor.$Revision: Info" --msgbox "Please click OK, then wait while I display file" 11 50
                sleep 2
                $MyDialog --title "$ME-$Minor.$Revision: Supplied RFCs" --textbox $MYFILE 600 800
                sleep 5
             ;;
             *) # Anything else aside from whiptail or kdialog
                $MyDialog --title "$ME-$Minor.$Revision: Supplied RFCs $MYLINES $MYLISTX" --textbox $MYFILE "$MYLINES" "$MYLISTX"
                ;;
        esac
    fi
# Comment out the next line if you want a copy to be left behind - normally
# we would clean up behind us, however.
    rm -rf $MYFILE
}

PdfEngine() {
  ################
  # ! Hey, what's THIS doing in here?
# Lets look for either of acroread, xpdf, kpdf, evince or gv
    MyAcro=$( type -p acroread 2>/dev/null )
    MyXpdf=$( type -p xpdf 2>/dev/null )
    MyKpdf=$( type -p kpdf 2>/dev/null )
    MyGv=$( type -p gv 2>/dev/null  )
    MyEvince=$( type -p evince 2>/dev/null )
    First=${MyAcro:-$MyEvince}
    Second=${MyXpdf:-$MyGv}
    Third=${First:-$Second}
    MyPDFViewer=${Third:-$MyKpdf}
    unset First Second Third
# ZD: Needs to be commented, or at least needs a header introducing it ;)
# Right. Let's see if any of these were found. If so....
    if [ "$MyPDFViewer" ]; then
      if [ $DISPLAY ]; then
        MYLINES=11
        MyNotify  "$ME-$Minor.$Revision: running external viewer $MyPDFViewer"
# ! Thank goodness none of these files have any spaces in their names.
          $MyPDFViewer $MYFILE.pdf
      else
        MYLINES=11
        MyError "You haven't got X running, or you didn't export DISPLAY"
      fi
    else # nope, guess we didn't find a reader.
        MyError "We were unable to find a PDF viewer on your system"
    fi
# Comment out the next line if you want a copy to be left behind - normally
# we would clean up behind us, however.
# ZD: NEVER EVER(!!!) rm -rf a file, always rm -f, if 
# ZD: the file turns out to be something else, things can get messy
    rm -f $MYFILE.pdf
}

PsEngine() {
# ZD: I like your wrappers, but perhaps they should all be at one place so
# ZD: they are easier to find?
# Surely there MUST be more than one PS viewer - and we don't 
# need X either, but I don't account for SVGA/fb here.
    MyPsViewer=$(type -p gv 2>/dev/null)
    if [ "$MyPsViewer" ]; then
        if [ $DISPLAY ]; then
          MYLINES=11
          MyNotify "running external viewer $MyPsViewer"
          $MyPsViewer $MYFILE.ps
        else
# This error message makes no sense to non-geeks
          MYLINES=11
          MyError "You haven't got X running, or you didn't export DISPLAY"
        fi
    else
      MYLINES=11
      MyStatus "Unable to find PostScript viewer such as GhostView"
      MyError "We were unable to find a Postscript viewer on your system. Try installing GhostView."
    fi
# Comment out the next line if you want a copy to be left behind - normally
# we would clean up behind us, however.
# ZD: rm -rf again
    rm -f $MYFILE.ps
}

RenderCore() {
####################################################################################
# The framework that delivers to the above routines.
# one weakness is that it only checks one place - cwd - normally $PLACE
# We need to check $WRITEABLE and $INDEX for -index/xx00/-ref
# It doesn't take -index on debian into account...
# Also, this should only be responsible for rendering, not for finding or
# for asking user if they want to download ... which means a rewrite for Render*
# We should hand it a definitive place, and type.
#################################
# I also think we've duplicated code here with GoCat... but it's not 100% duplicated
# which means some inefficiency.
# Whoops. I've just realised this should be set OUTSIDE this routine...
#    Format
#    ewww. just realised it looks for $this/$that.txt.*
    RFCFile="$FORMAT""$Val"
# ZD: This can all probably be done in alot less code by using a loop
# ! This line doesn't take into account the PLACE!
# ! It's also turning up false positives - bleah!
#    echo "Trying in $HEREPLACE for $RFCFile.$DEFEXT"
#    read mubrle
    if [ "`ls $HEREPLACE | grep -e $RFCFile.$DEFEXT`" ]; then
      MyStatus "Entering GoCat"
  #  file-type detection and decompression as per type
      if [ -f $HEREPLACE/$RFCFile.$DEFEXT ]; then
        case $DEFEXT in 
            pdf) 
                GoCat > $MYFILE.pdf
                PdfEngine ;;
            txt) 
                GoCat | tr -d '\014\015' > $MYFILE
                RfcEngine ;;
            ps) 
                GoCat > $MYFILE.ps
                PsEngine ;;
        esac
      elif [ -f $HEREPLACE/$RFCFile.txt.gz ]; then
        GoCat | tr -d '\014\015' > $MYFILE
        RfcEngine
      elif [ -f $HEREPLACE/$RFCFile.txt.bz2 ]; then
#  RfcEngine
        if [ "$Val" = "-ref" ]; then
          if [ "$FORMAT" = "rfc" ]; then
            MYLISTX=$((MYX - 2 ))
      # Replace with more folded lines than normal, as this file
      # is DEFINITELY wider than 72 chars
            GoCat | fold -s -w $((MYX - 5)) | tr -d '\014\015'> $MYFILE
          else
            echo "Sorry, the document $FORMAT-ref doesn't exist." > $MYFILE
          fi
        else
          GoCat | tr -d '\014\015'> $MYFILE
        fi
        RfcEngine
      elif [ -f $HEREPLACE/$RFCFile.txt ]; then
        GoCat | tr -d '\014\015' > $MYFILE
        RfcEngine
# Now we shift a notch - we've got problems here, if we haven't
# selected pdf or ps, but we have it INSTEAD of the .txt, then
# our user's gonna get a surprise. Breaks the TAOUP "least surprise" rule.
# Other alternative is where we've called for pdf, but we have txt
      elif [ -f $HEREPLACE/$RFCFile.pdf ]; then
        GoCat > $MYFILE.pdf
        PdfEngine
      elif [ -f $HEREPLACE/$RFCFile.pdf.gz ]; then
        GoCat > $MYFILE.pdf
        PdfEngine
      elif [ -f $HEREPLACE/$RFCFile.txt.pdf ]; then
        GoCat > $MYFILE.pdf
        PdfEngine
      elif [ -f $HEREPLACE/$RFCFile.txt.pdf.gz ]; then
        GoCat > $MYFILE.pdf
        PdfEngine
      elif [ -f $HEREPLACE/$RFCFile.ps ]; then
        GoCat > $MYFILE.ps
        PsEngine
      elif [ -f $HEREPLACE/$RFCFile.ps.gz ]; then
        GoCat > $MYFILE.ps
        PsEngine
      else
        MyError "$ME-$Minor.$Revision: What the hey?  I fell out of RenderCore with no result. Hit enter to continue"
      fi
    elif [ "`ls $HEREPLACE | grep -e $RFCFile.txt.$DEFEXT`" ]; then
      GoCat > $MYFILE.pdf
      PdfEngine
      rm  -f $MYFILE.pdf
    else
  # Weakness here - we never check negative numbers or non-numbers.
      if [ "$Val" = 0 ]; then
        MYLINES=11
        MyError "We can't download or show ${FORMAT}0, sorry.\nIt doesn't exist."
      else
# This is where we offer to fetch the missing rfc - there's been an inconsistency listed
# here that 0 shows up, but can't (obviously) be downloaded. Hence the addition of the previous code
# ZD: Perhaps you should write a wrapper for your dialogs so that you can easily
# ZD: add other interfaces (ask me about xmsg)
        case $FORMAT in 
          bcp|fyi|std)
            $MyDialog --title "$ME-$Minor.$Revision: error!" --yesno "Sorry, $FORMAT$Val.$DEFEXT is not in this database.\n\
$ME -index will give you the current documents here.\n\
Shall I try to fetch $FORMAT$Val.txt from\n\
$REMOTEPLACE$FORMAT ?" 11 50
            retval=$?
            ;;
          rfc)
            $MyDialog --title "$ME-$Minor.$Revision: error!" --yesno "Sorry, $FORMAT$Val.$DEFEXT is not in this database.\n\
$ME -index will give you the current documents here.\n\
Shall I try to fetch $FORMAT$Val.txt from\n\
$REMOTEPLACE ?" 11 50
            retval=$?
            ;;
        esac
        if [ "$retval" = 0 ]; then
          REMOTEFILE=$FORMAT$Val.$DEFEXT
          Num=$Val
          Val=-get
          FetchSingle
      fi
    fi # End of test for $Val = 0
  fi # We leave if the file exists, without hitting the preceding code.
}

############# End of engine code ###################



# ZD: The same length of the ############# lines everywhere would make it looks better
########################################################
#
# Menu group code - cutesy dialog menus that call the 
# next with the current values
# We call thousands first, then Hundreds, tens, and
# finally units, showing titles if present.
#
########################################################

MenuCore() {
###########################################################
# This calls each menu in turn, gaining a value in Val
# Now, how the heck do we exit the menu WITHOUT a Val?
# Also, this menu's "bouncy" - we get locked in
###########################################################
    MYLINES=17
    if [ "$MAXK" -eq "0" ]; then
        K=0
    else
        KMenuGroup
        DeadYet
    fi
    if [ "$menulevel" -gt 0 ]; then
        if [ "$MAXK" -eq "0" -a "$MAXH" -eq "0" ]; then
            H=0
        else
            HMenuGroup
            DeadYet
        fi
    fi
    if [ "$menulevel" -gt 0 ]; then
        if [ "$MAXK" -eq "0" -a "$MAXH" -eq "0" -a "$MAXT" -eq "0" ]; then
            T=0
        else
            TMenuGroup
            DeadYet
        fi
    fi
    if [ "$menulevel" -gt 0 ]; then
        SubMenuGroup
        DeadYet
    fi
    if [ "$K" -a "$H" -a "$T" -a "$U" ]; then
      # We could glue "rfc" onto the front, but then that'd break stuff
        Val=$(($K + $H + $T + $U))
        MYLINES=$MYY
        menulevel=2
    else
        menulevel=0
    fi
# Hmmm - what do we have for "else"? noexit=0?
#      Val=0
#      MYLINES=$MYY
#    else
}

##############################
# Help-associated menu entries.
##############################

Help() {
#  MyString=( 0 "Global help - what this program does" H 'Help! Help!' 1 "View single RFC by number" 2 "View Range of RFCs" 9 "Pick RFC by number from list" K "Text RFCs without number" D "Directory of local RFCs" I "RFC Index (total)" C "Check titles" S "Search RFC Index" T "Show title of RFC" G "Get single RFC" R "Get RFC Range" L "Get Latest RFCs" X "Exit the Help menu" )
    MyString=( Z "Global help for the program" H 'Help! Help!' 1 "View single RFC by number" 2 "View Range of RFCs" 0 "Pick RFC by number from list" N "Text RFCs without number" 9 "Directory of local RFCs" I "RFC Index (total)" C "Check titles" / "Search RFC Index" T "Show title of RFC" G "Get single RFC" R "Get RFC Range" L "Get Latest available RFCs" F "FYI index" S "STD index" B "BCP Index" X Exit )
    if [ "$MyDialog" = "$MyKDialog" ]; then
        Out=$($MyDialog --title "$ME-$Minor.$Revision: Select" --menu "Select help with task" "${MyString[@]}" 2>&1 )
        $MyDialog --title "$ME-$Minor.$Revision: Info" --msgbox "Thank you. Hit Enter (or click OK) and wait while I set up" 7 30
#        BugAuthor
    else
        Out=$($MyDialog --title "$ME-$Minor.$Revision: Select" --menu "Select help with task" 24 40 17 "${MyString[@]}" 2>&1 >$(tty))
    fi
    retval=$?
  # DeadYet changes menulevel to 0
    DeadYet
    if [ "$menulevel" -gt 0 ]; then
      case $Out in
        0) HelpPick ;; # Pick RFC by number from list
        1) HelpVSingle ;; # View Single RFC by number
        2) HelpVRange ;; # View Range of RFCs
        9) HelpDir ;; # Dir of local RFCs
        B) HelpBCP ;; # Show BCP index
        C) HelpCheck ;; # Check Titles
        F) HelpFYI ;; # Show FYI index
        G) HelpGet1 ;; # Get single RFC
        H) HelpHelp ;; # HELP!
        I) HelpIndex ;; # Global index
        L) HelpGetLatest ;; # Get Latest RFCs
        N) HelpText ;; # Text RFCs (no numbers)
        R) HelpGetRange ;; # Get RFC Range
        /) HelpSearch ;; # Search RFC Index
        S) HelpSTD ;; # Show STD index
        T) HelpTitle ;; # Show title of RFC
        X) HelpExit
        noexit=0
        RfcEngine
         ;;
        Z) HelpGlobal ;; # Global help (describes the program as a whole)
      esac
    fi
}

HelpGlobal() {
  # Global Help, what the program does
  title="Global Help for RFCShow"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=23 ;;
    *) MYLINES=19 ;;
  esac
  echo -ne "Welcome to the RFCShow program. If you wish to view RFC
documents, this program does it all, including finding, fetching\n\
and displaying documents to you in a variety of possible formats,\n\
including text, pdf, or PostScript(TM). There are currently $MAXVAL\n\
documents here, and there are probably more up at the remote site\n\
$REMOTEPLACE to fetch if you wish.\n\n\
So, let's get started with the documents on your own computer\n\
stored in $PLACE.\n" > $MYFILE
    if [ "$WRITEABLE" -a "$PLACE" != "$WRITEABLE" ]; then
        echo -ne "If you ask for ones I don't have, I'll get them from:\n\
  $REMOTEPLACE\n\
and put them here:\n\
  $WRITEABLE\n" >> $MYFILE
    elif [ "$WRITEABLE" ]; then
        echo -ne "If you ask for ones I don't have, I'll get them from:\n\
$REMOTEPLACE\n" >> $MYFILE
    else
        echo -ne "but you need to make a directory so I can download other\n\
RFC documents to it. You can either create your own, as in\n\
/home/$USER/rfc, or ask the admin to change the permissions for\n\
$PLACE\n" >> $MYFILE
    fi
}

HelpVSingle() {
# View Single RFC by number
  title="View a single RFC"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "Enter a single RFC/BCP/STD/FYI number into the text box. If the RFC exists\n\
locally, it will be shown to you. If it exists in the database,\n\
but it is not stored locally, you will be asked if you want to\n\
download the RFC document to your machine." > $MYFILE
}

HelpVRange() { 
# View Range of RFCs
  title="View a range of RFC documents"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This option allows you to view a range of RFC documents\n\
from the smallest number to the largest number that you wish.\n\
It's a bit difficult to break out of the loop if you don't want\n\
to view any more documents, so take care not to make the range\n\
too large." > $MYFILE
}

HelpBCP() {
# View BCP index
  title="View index of Best Common Practice documents"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This shows you what BCP documents are available from\n\
$REMOTEPLACE in the form\n\
of a searchable list. The index also describes what RFC documents\n\
have been superceded by others, and what formats they are stored in.\n\
Included are authors, size, and current status of document." > $MYFILE
}

HelpSTD() {
# View STD index
  title="View index of STD documents"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This shows you what STD documents are available from\n\
$REMOTEPLACE in the form\n\
of a searchable list. The index also describes what RFC documents\n\
have been superceded by others, and what formats they are stored in.\n\
Included are authors, size, and current status of document." > $MYFILE
}

HelpFYI() {
# View FYI index
  title="View index of FYI documents"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This shows you what FYI documents are available from\n\
$REMOTEPLACE in the form\n\
of a searchable list. The index also describes what RFC documents\n\
have been superceded by others, and what formats they are stored in.\n\
Included are authors, size, and current status of document." > $MYFILE
}

HelpPick() {
# Pick RFC by number from list
  title="View a single RFC from list of numbers"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=21 ;;
    *) MYLINES=15 ;;
  esac
  echo -ne "This displays four lists of numbers, first thousands, then\n\
hundreds, then tens, then finally an individual RFC from the list.\n\
If this sounds confusing, then go try it, and come back if you're still\n\
confused. The neat thing about this list is that by the time you get\n\
to see the last list of individual RFC documents, you should hopefully\n\
see the titles of those shown beside the entries so you know whether\n\
you have the right document.\n\n\
Good luck with this." > $MYFILE
}

HelpDir() {
# Dir of local RFCs
  title="Directory of local RFC documents"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This shows you a directory of the RFCs stored on your machine\n\
in your selected directory store; this directory is here on yours:
  $PLACE
You can provide a pattern to apply against the list of files to\n\
show just those files, or merely hit Enter to accept the default.\n\
" > $MYFILE
}

HelpGet1() {
# Get single RFC
  title="Get a single RFC"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This retrieves the requested RFC document from the remote server\n\
if it exists there. If it doesn't, then you'll get told (eventually) that\n\
the server doesn't have that file.\n\
This program MAY overwrite files you already have, so use this with\n\
caution." > $MYFILE
}

HelpHelp() {
# The Normans are invading!
  title="Help"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "You're reading it! Yep! This help describes the Help section\n\
of the rfcshow program. You navigate to an entry using the cursor keys\n\
then hit <OK> to choose an entry. Select <Cancel> or the Exit menu entry \n\
to leave. Basically, the same as anywhere else in the program.\n\
The remainder of the help screens describe the rest of the menu\n\
interface, but it's pretty easy to follow through." > $MYFILE
}

HelpIndex() {
# Global index
  title="Display RFC Index"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This shows you what RFC documents are available from\n\
$REMOTEPLACE in the form\n\
of a searchable list. The index also describes what RFC documents\n\
have been superceded by others, and what formats they are stored in.\n\
Included are authors, size, and current status of document." > $MYFILE
}

HelpText() {
# Text RFCs (no numbers)
  title="Text RFCs (non-numeric)"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This displays a menu of RFC documents that aren't in the numeric\n\
series, like rfc-instructions, rfc-ref and other documents.\n\
Select the entry you want, and enjoy." > $MYFILE
}

HelpGetLatest() {
# Get Latest RFCs
  title="Get latest RFC documents"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "\
This analyses the locally stored documents and compares them with the\n\
latest available documents stored at $REMOTEPLACE\n\
The program will hopefully download the documents that exist on the\n\
remote end but aren't stored locally, so you can catch up once or twice\n\
a month.\n\
There's a degree of overlap built in to the program, just to catch up\n\
on documents that were added to the remote end, but which haven't been\n\
stored locally yet." > $MYFILE
}

HelpCheck() {
# Check Titles
  title="Check titles"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This prompts you for a search term, then shows you descriptions\n\
in the rfc index that match that same pattern. To view those documents,\n\
choose <Search RFC Index> instead, and provide a search term. See\n\
<Search and Display Titles> in this help menu for more details." > $MYFILE
}

HelpGetRange() { 
# Get RFC Range
  title="Fetch RFC Range"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "You are able to fetch ranges of RFC documents with this; for example\n\
all rfc documents from 3,200 to 3,500, or 100 to 600. If you wish to\n\
fetch large ranges of documents, then getting the tarballs may be a better\n\
idea for you, as they are downloadable in 500-document tarballs.\n\n\
The same warning applies to this function as the <Get RFC> function\n\
in that it MAY erase documents you already have. I hope not, but\n\
the possibility always exists that my coding may run amok." > $MYFILE
}

HelpSearch() {
# Search RFC Index
  title="Search and display titles"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This prompts you for a term, then gives you a list of\n\
documents for you to select entries you wish to view which match the term.\n\
This differs from the Check Titles entry in that you can select what RFC\n\
documents match the term you want, and display those RFC documents.\n\
  " > $MYFILE
}

HelpTitle() {
# Show title of RFC
  title="Show title of RFC"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "Input a number, you'll be shown the description of the\n\
matching document. So simple, you'll wonder why you didn't think of it.\n\
  " > $MYFILE
}

# These four describe what they're supposed to do.

HelpPDF() {
  title="Set output format to PDF"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This commandline switch sets the output format of requested documents\n\
to AdobeReader(TM) Portable Document Format (PDF). If you have the required\n\
RFC in pdf format, rfcshow will call on a PDF viewer installed on your\n\
system.  So far, I've found " > $MYFILE
if [ "$MyPDFViewer" ]; then
  echo -ne "$MyPDFViewer on the system\nso I'll use this program.\n" >> $MYFILE
else
  echo -ne "nothing on the system to view PDF files with.\n
You will need to install one (or more if you want) of the following programs:\n\
AcroRead for Linux (or Windows if you're running this under cygwin)\n\
XPdf (which may require GhostScript installed)\n\
or GhostView (which also requires the installation of GhostScript).\n" >> $MYFILE
fi
}

HelpPS() {
  title="Set output format to PostScript"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This commandline switch sets the output format of requested documents\n\
to Adobe PostScript format. If you have the required RFC in ps format,\n\
rfcshow will call on a PS viewer installed on your system. If you\n\
don't have one, then you will be prompted to install one before you\n\
can view ps files." > $MYFILE
}

HelpTXT() {
  title="Set output format to text"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This commandline switch sets the output format of requested documents\n\
to plain text format. It is the default output format for rfcshow, and\n\
if you have the required RFC in txt format, rfcshow will display the\n\
requested RFC in a scrolling window on your screen." > $MYFILE
}

HelpSTD() {
  title="Standards index"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=7 ;;
  esac
  echo -ne "This commandline switch sets the output format of requested documents\n\
to straight text, output to the console stream where you started rfcshow\n\
from. If you have the required RFC in text format, rfcshow will extract\n\
that file, and send it to the screen to be viewed by a pager application,\n\
such as more or less. You'd normally call rfcshow like this:\n\
rfcshow --stdout <number> | less\n\
to get that rfc." > $MYFILE
}

HelpExit() {
  title="Let's blow this joint"
  case $MYDIALOG in 
    $MYWHIPTAIL) MYLINES=11 ;;
    *) MYLINES=10 ;;
  esac
  echo -ne "You are now exiting the Help screen of $ME. If you wish\n\
to return to this help menu, simply choose 'Help! Help!' from the\n\
front menu again." > $MYFILE
}

#################################################################
# This code acts as a front end, to select tasks
#################################################################

TaskSelect() {
# Don't forget to take the vagaries of whiptail or old dialog into account
# I'm still working out how to integrate BCP/FYI/STDs to this listing 
    menulevel=1
#    MyString=( H 'Help! Help!' 1 "View single RFC by number" 2 "View Range of RFCs" 9 "Pick RFC by number from list" K "Text RFCs without number" D "Directory of local RFCs" I "RFC Index (total)" C "Check titles" S "Search RFC Index" T "Show title of RFC" G "Get single RFC" R "Get RFC Range" L "Get Latest available RFCs" X Exit )
    MyString=( H 'Help! Help!' 1 "View single RFC by number" 2 "View Range of RFCs" 0 "Pick RFC by number from list" N "Text RFCs without number" 9 "Directory of local RFCs" C "Check titles from index" / "Search RFC Index" T "Show title of RFC from index" G "Get single RFC" R "Get RFC Range" L "Get Latest available RFCs" I "RFC Index" F "FYI index" S "STD index" B "BCP Index" X Exit )
    if [ "$MyDialog" = "$MyKDialog" ]; then
      Out=$($MyDialog --title "$ME-$Minor.$Revision: Select" --menu "Select task: latest local RFC $MAXVAL" "${MyString[@]}" 2>&1 )
      retval=$?
      $MyDialog --title "$ME-$Minor.$Revision: Info" --msgbox "Thank you. Hit Enter (or click OK) and wait while I set up" 7 30
#      BugAuthor
    else
      Out=$($MyDialog --title "$ME-$Minor.$Revision: Select" --menu "Select task: latest local RFC $MAXVAL" 24 40 17 "${MyString[@]}" 2>&1 >$(tty))
      retval=$?
    fi
  # DeadYet changes menulevel to 0
    DeadYet
    if [ "$menulevel" -lt 1 ]; then
        Out=X
    fi
	# ZD: Again, waht this does is pretty unclear without comments
    case $Out in
        1) Q=--prompt ;;
        2) Format
            SetFormatDone=1
            PromptForNumber "Bottom of range"
            DeadYet
            if [ "$menulevel" -gt 0 ]; then
                Val1=$Val
                PromptForNumber "Top of range"
                DeadYet
                if [ "$menulevel" -gt 0 ]; then
                    Val2=$Val
                    REST="$Val1 $Val2 $REST"
                    Q=--range
                fi
            fi
            ;;
        9) Q=--list ;;
        0) Q=--menu ;;
        B) Q=bcp-index ;;
        C) Q=--searchtitles ;;
        F) Q=fyi-index ;;
        G) 
          # First one gives me $Val, pair this up with -get, guess what we have...
            Format # yes, we have to stick it in here to get the right value.
            PromptForNumber
            DeadYet
            if [ "$menulevel" -gt 0 ]; then
                REST="$Val $REST"
                Q=--get 
            fi
            ;;
        H) Q=--help ;;
        I) Q=rfc-index ;;
        L) Q=--getlatest ;;
        N) Q=--itemlist ;;
        R) Format
        PromptForNumber "Bottom of range"
            DeadYet
            if [ "$menulevel" -gt 0 ]; then
                Val1=$Val
                PromptForNumber "Top of range"
                DeadYet
                if [ "$menulevel" -gt 0 ]; then
                    Val2=$Val
                    REST="$Val1 $Val2 $REST"
                    Q=--getrange
                fi
            fi
            ;;
        S) Q=std-index ;;
        T) Q=--title ;;
        X) Q=--exit
            noexit=0 ;;
        '/') Q=--search ;;
    esac
    case $Q in 
        --prompt|--menu) DEFEXT=$($MyDialog --title "$ME-$Minor.$Revision: output format" --menu "Select output format" 12 40 5 txt Text pdf PDF ps PS stdout Stdout 2>&1 >$(tty))
            DeadYet
    # Need to do a condition test for menulevel=0
            ;;
    esac
    if [ "$DEFEXT" = "stdout" ]; then
        DEFEXT=txt
           # Add stdout flag
        STDOUT=1
    fi
    if [ "$menulevel" -gt 0 ]; then
        ParseSwitch
    fi
}

KMenuGroup() { # Kilo (thousand)
# Original comments:
# This list will need to be expanded when the RFCs get beyond 4999
# ... otherwise I'll make it a brighter program that works out what the maximum
# values are from MAXVAL - we do have a MAXK value I ought to learn to leverage.
# New comments:
# Contributed bit of code to leverage MAXK for menus. 
# Only hassle is, it doesn't show for files: [MAXVAL..MAXREMOTEVAL]
    K=$($MyDialog --title "Supplied RFCs" --menu "RFC master list" "$MYLINES" 40 $(( $MYLINES - 7 )) \
        0 rfc1-rfc999 \
        $(for ((i=1;i<=MAXK;i++)) ; do echo -n "${i}000 rfc${i}000-rfc${i}999 "; done) \
        2>&1 1>$(tty))
    retval=$?
    # Reason for this is because rfc filenames are not zero-padded,
    # even though their entries in rfc-ref are zero-padded, so we have to provide
    # a variable either way.
    M=$(($K/1000))
    Ma=$(($K/1000))
    if [ $M -eq 0 ]; then
        M=""
    fi
}

#        1000 rfc1000-rfc1999 \
#        2000 rfc2000-rfc2999 \
#        3000 rfc3000-rfc3999 \
#        4000 rfc4000-rfc4999 \

HMenuGroup() { # Hecto (hundred)
    local MYVAL
#        if [ $Ma -le $MAXK ]; then
    MYVAL=9
#        else
#          MYVAL=$MAXH
#        fi
    H=$($MyDialog --title "Supplied RFCs" --menu "RFC master list" "$MYLINES" 40 $(( $MYLINES - 7 )) \
        0 rfc"$M"000-rfc"$M"099 \
        $(for ((i=1;i<=MYVAL;i++)) ; do echo -n "${i}00 rfc$M${i}00-rfc$M${i}99 "; done) \
        2>&1 1>$(tty))
    retval=$?
    C=$(($H/100))
    Ca=$(($H/100))
    if [ "$M" = "" ]; then
        if [ $C -eq 0 ]; then
            C=""
        fi
    fi
}

TMenuGroup() { # Tens
    local MYVAL
    MYVAL=9
    T=$($MyDialog --title "Supplied RFCs" --menu "RFC master list" "$MYLINES" 40 $(( $MYLINES - 7 ))  \
        0 rfc"$M$C"00-rfc"$M$C"09 \
        $(for ((i=1;i<=MYVAL;i++)) ; do echo -n "${i}0 rfc$M$C${i}0-rfc$M$C${i}9 "; done) \
        2>&1 1>$(tty))
    retval=$?
    X=$(($T/10))
    Xa=$(($T/10))
    if [ "$M" = "" ]; then
        if [ "$C" = "" ]; then
            if [ $X -eq 0 ]; then
                X=""
            fi
        fi
    fi
}


# ... and finally, the last menu. This is the one that shows available titles.

SubMenuGroup() { 
# Units
# We might as well just do the [b[z]]grep once, instead of up to ten times.
# we can do a normal grep once we have the file in text form.
# not only that, but we might as well use our MYFILE for the tempfile - it will
# be written over each time we either check out a RFC, or we create this list.
# also, we have to allow for $TITLES from non-compressed format, or gzip
# hmmm... could I replace these with GoCat?
# ZD: Now this is pretty code :)
    if [ -f ${PLACE}rfc$TITLES.txt.bz2 ]; then
        bzgrep "^RFC$Ma$Ca$Xa[0-9] " ${PLACE}rfc$TITLES.txt.bz2 > $MYFILE
    elif [ -f ${PLACE}rfc$TITLES.txt.gz ]; then
        zgrep "^RFC$Ma$Ca$Xa[0-9] " ${PLACE}rfc$TITLES.txt.gz > $MYFILE
    elif [ -f ${PLACE}rfc$TITLES.txt ]; then
        grep "^RFC$Ma$Ca$Xa[0-9] " ${PLACE}rfc$TITLES.txt > $MYFILE
    fi

#    DescArray=($(cat $MYFILE | sed -r -e 's/[^\"]*\"(.*)\"\,.*/\1/' -e 's/"/\\"/g'))
# Theoretically, this could have used one test, and just listed the titles
# regardless of whether we HAD them or not, but I wanted an indication of
# the files if they were missing in local store
#    for I in 0 1 2 3 4 5 6 7 8 9; do
      # I'm sure this ought to be simpler; one test, instead of 8
#        if [ -f rfc"$M$C$X$I"."${DEFEXT}".bz2 ]; then
#            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^\"]*\"(.*)\"\,.*/\1/' -e 's/"/\\"/g' )"
#        elif  [ -f rfc"$M$C$X$I".txt.gz ]; then
#            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^\"]*\"(.*)\"\,.*/\1/' -e 's/"/\\"/g' )"
#        elif  [ -f rfc"$M$C$X$I".txt ]; then
#            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^\"]*\"(.*)\"\,.*/\1/' -e 's/"/\\"/g' )"
#        elif  [ -f rfc"$M$C$X$I".txt.pdf ]; then
#            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^\"]*\"(.*)\"\,.*/\1/' -e 's/"/\\"/g' )"
#        elif  [ -f rfc"$M$C$X$I".pdf ]; then
#            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^\"]*\"(.*)\"\,.*/\1/' -e 's/"/\\"/g' )"
#        elif  [ -f rfc"$M$C$X$I".pdf.gz ]; then
#            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^\"]*\"(.*)\"\,.*/\1/' -e 's/"/\\"/g' )"
#        elif  [ -f rfc"$M$C$X$I".ps ]; then
#            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^\"]*\"(.*)\"\,.*/\1/' -e 's/"/\\"/g' )"
#        elif  [ -f rfc"$M$C$X$I".ps.gz ]; then
#            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^\"]*\"(.*)\"\,.*/\1/' -e 's/"/\\"/g' )"
#        else
#            D[$I]="N"; B[$I]="$I missing"
#        fi
#    done
    ############## New Code #################
    # New code to replace the for loop above, don't put it into action until we're sure
    # that we have it all correct. This has the advantage of ONLY checking *.$DEFEXT.*
    for I in 0 1 2 3 4 5 6 7 8 9; do
      case $DEFEXT in
        txt)
          if [ -f rfc"$M$C$X$I".txt.bz2 ]; then
#            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^\"]*\"(.*)\"\,.*/\1/' -e 's/"/\\"/g' )"
            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^"]*"(.*)",.*/\1/' )"
          elif  [ -f rfc"$M$C$X$I".txt.gz ]; then
            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^"]*"(.*)",.*/\1/' )"
          elif  [ -f rfc"$M$C$X$I".txt ]; then
            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^"]*"(.*)",.*/\1/' )"
          else
            D[$I]="N"; B[$I]="$I missing"
          fi
        ;;
        pdf) 
          if  [ -f rfc"$M$C$X$I".txt.pdf ]; then
            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^"]*"(.*)",.*/\1/' )"
          elif  [ -f rfc"$M$C$X$I".pdf ]; then
            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^"]*"(.*)",.*/\1/' )"
          elif  [ -f rfc"$M$C$X$I".pdf.gz ]; then
            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^"]*"(.*)",.*/\1/' )"
          else
            D[$I]="N"; B[$I]="$I missing"
          fi
        ;;
        ps)
          if  [ -f rfc"$M$C$X$I".ps ]; then
            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^"]*"(.*)",.*/\1/' )"
          elif  [ -f rfc"$M$C$X$I".ps.gz ]; then
            D[$I]=$I; B[$I]="$I $(grep "^RFC$Ma$Ca$Xa$I " $MYFILE | sed -r -e 's/[^"]*"(.*)",.*/\1/' )"
          else
            D[$I]="N"; B[$I]="$I missing"
          fi
        ;;
      esac
    done
    ############## End of new code ######################
  # Another string builder created from the previous for loop
    for ((this=0;this<10;this++)) do
      that=$(( $this * 2 )); 
      munchstring[that++]="$this"
      munchstring[that++]="rfc$M$C$X${B[$this]}"
    done
    # ... and the resulting menu
    U=$($MyDialog --title "Supplied RFCs" --menu "RFC Decimal" "$MYLINES" "$(( $MYX - 2 ))" $(( $MYLINES - 7 )) "${munchstring[@]}" 2>&1 1>$(tty))
    retval=$?
}

# This queries the user for a number, feeding it back into $Val for RenderCore

PromptForNumber() {
    Val=$( $MyDialog --title "$ME-$Minor.$Revision: $1" --inputbox "What $FORMAT Number? (0-$MYMAXVAL)" 8 45 \
        2>&1 1>$(tty))
    retval=$?
}

# TODO: I'd LOVE to add the description as a menu entry.

ChooseList() {
  MYVAL=${#VarArray[@]}
# Here, we have to choose what RFCs I want to choose titles for.
# Time for a for loop, though I'm commenting it right out of place until I have what I want.
  echo "" > $MYFILE # clear out the file
  for this in ${VarArray[@]}; do
    if [ -f ${PLACE}rfc$TITLES.txt.bz2 ]; then
      bzgrep "^RFC$this " ${PLACE}rfc$TITLES.txt.bz2 >> $MYFILE
    elif [ -f ${PLACE}rfc$TITLES.txt.gz ]; then
      zgrep "^RFC$this " ${PLACE}rfc$TITLES.txt.gz >> $MYFILE
    elif [ -f ${PLACE}rfc$TITLES.txt ]; then
      grep "^RFC$this " ${PLACE}rfc$TITLES.txt >> $MYFILE
    fi
  done
# Now it's time we stripped prepended 0 off the RFC numbers
  for ((i=0;i<${#VarArray[@]};i++)); do
      VarArray[i]="$(echo ${VarArray[$i]} | sed 's/^0\+//')"
  done
  O=$IFS
  IFS=$'\n'
# ZD: All hail obscurity?
# I asked for a sed line to give me lines from the first " on a line to the
# last " on a line, without the ", but with embedded " turned into \"
# Thanks to ThomasM for this.
  DescArray=($(cat $MYFILE | sed -r -e 's/[^\"]*\"(.*)\"\,.*/\1/' -e 's/"/\\"/g'))
  IFS=$O
  that=0
# I have to do some counter magic in here to get the array members correct.
# Was supposed to be:
#       for that=0; mumb[that++]="one"; mumb[that++]="two" .... done
# only, I can't get the counter right
  for ((this=0;this<MYVAL;this++)) do
# This ought to be 3 for use without --item-help
# or 4 for use with --item-help
    that=$(( $this * 3 )); 
#    that=$(( $this * 4 ));
#   munchstring[that++]="$this"
    munchstring[that++]="${VarArray[$this]}"
    munchstring[that++]="${DescArray[$this]}"
    munchstring[that++]="off"
  done
  declare -a Res
  Res=($($MyDialog --title "Supplied RFCs" --checklist "Select for viewing" "$MYLINES" 80 $(( $MYLINES - 7 ))  \
      "${munchstring[@]}"  2>&1 1>$(tty)))
  result=$?
# Bug on dialog > 0.9 fixed - they now output "1" "2" instead
# of 1 2
# ewps. Is this an array?
   for ((j=0;j<${#Res[@]};j++)) do
     Res[$j]=$(echo ${Res[$j]} | tr -d '"')
   done
  if [ $result = 0 ]; then
    for ((this=0;this<${#Res[@]};this++)) do
      Q="${Res[$this]}"
      ParseSwitch
    done
  fi
}


############## End of menu code #########################

#############################################################
# Fetching code
#############################################################

ParseLatestList() {
  local Val
# First, get "ls " of ftp.rfc-editor.org/in-notes/, stick it in a temp file.
# If we have got it already this session, don't bother, process straight away.
# * only place this is weak is if the remote has changed in the time we have
#   been running this program.
# + Considering using this to get whatever dir we want, passed in from $REMOTEPLACE
# ! Something's tripping over the non-changing MAXVAL, should we actually do the size
#   check first?
  if [ "$MYGET" ]; then
      case $FORMAT in bcp)
        GotMyDir=$GotBCPDir
        ;;
        fyi)
        GotMyDir=$GotFYIDir
        ;;
        rfc)
        GotMyDir=$GotDir
        ;;
        std)
        GotMyDir=$GotSTDDir
        ;;
      esac
      if [ -z "$GotMyDir" ]; then
#            echo "$ME-$Minor.$Revision: Fetching $FORMAT list with $MYGET - please await results"
            case $MYGET in 
                $MYNCGET)
                    $MYNCLS $MYLSPARM $THEREPLACE > $FORMAT$DIRLIST ;;
                *) 
#                MYLINES=7
#                MyNotify "Now calling curl on $THEREPLACE" 7 40
                $MYGET $MYDIRPARM $THEREPLACE > $FORMAT$DIRLIST ;;
            esac
            Val=$?
    # This is where error returns would need tailoring. curl uses 19 for (file not there) and 6 (site not there)
    # and 23 for can't write to local file
            case $FORMAT in
                rfc)
              case $Val in 
                0) GotDir=1 # make sure we don't download again within this program execution
                    MAXREMOTEVAL=$(cat $FORMAT$DIRLIST | grep "$FORMAT[[:digit:]]*.txt" 2>/dev/null | cut -c4- | sort -n | tail -n 1 | cut -d. -f1 ) 
                   MyStatus "$ME-$Minor.$Revision: Got $FORMAT list, latest local: $MAXVAL, latest remote: $MAXREMOTEVAL, now munching"  
                    ;;
                1) MyStatus "$ME-$Minor.$Revision: Request to $REMOTEPLACE failed - check the firewall, or try again later." ;;
                2) MyStatus "$ME-$Minor.$Revision: Request to $REMOTEPLACE timed out - try again later." ;;
                *) MyStatus "$ME-$Minor.$Revision: I struck another error from fetching program - $Val" ;;
              esac
                ;;
                bcp)
              case $Val in 
                0) GotBCPDir=1 # make sure we don't download again within this program execution
                    MAXREMOTEBCPVAL=$(cat $FORMAT$DIRLIST | grep "$FORMAT[[:digit:]]*.txt" 2>/dev/null | cut -c4- | sort -n | tail -n 1 | cut -d. -f1 ) 
                   MyStatus "$ME-$Minor.$Revision: Got $FORMAT list, latest local: $MAXBCPVAL, latest remote: $MAXREMOTEBCPVAL, now munching"  
                    ;;
                1) MyStatus "$ME-$Minor.$Revision: Request to $REMOTEPLACE failed - check the firewall, or try again later." ;;
                2) MyStatus "$ME-$Minor.$Revision: Request to $REMOTEPLACE timed out - try again later." ;;
                *) MyStatus "$ME-$Minor.$Revision: I struck another error from fetching program - $Val" ;;
              esac
                ;;
                fyi)
              case $Val in 
                0) GotFYIDir=1 # make sure we don't download again within this program execution
                    MAXREMOTEFYIVAL=$(cat $FORMAT$DIRLIST | grep "$FORMAT[[:digit:]]*.txt" 2>/dev/null | cut -c4- | sort -n | tail -n 1 | cut -d. -f1 ) 
                   MyStatus "$ME-$Minor.$Revision: Got $FORMAT list, latest local: $MAXFYIVAL, latest remote: $MAXREMOTEFYIVAL, now munching"  
                    ;;
                1) MyStatus "$ME-$Minor.$Revision: Request to $REMOTEPLACE failed - check the firewall, or try again later." ;;
                2) MyStatus "$ME-$Minor.$Revision: Request to $REMOTEPLACE timed out - try again later." ;;
                *) MyStatus "$ME-$Minor.$Revision: I struck another error from fetching program - $Val" ;;
              esac
                ;;
                std)
              case $Val in 
                0) GotSTDDir=1 # make sure we don't download again within this program execution
                    MAXREMOTESTDVAL=$(cat $FORMAT$DIRLIST | grep "$FORMAT[[:digit:]]*.txt" 2>/dev/null | cut -c4- | sort -n | tail -n 1 | cut -d. -f1 ) 
                   MyStatus "$ME-$Minor.$Revision: Got $FORMAT list, latest local: $MAXSTDVAL, latest remote: $MAXREMOTESTDVAL, now munching"  
                    ;;
                1) MyStatus "$ME-$Minor.$Revision: Request to $REMOTEPLACE failed - check the firewall, or try again later." ;;
                2) MyStatus "$ME-$Minor.$Revision: Request to $REMOTEPLACE timed out - try again later." ;;
                *) MyStatus "$ME-$Minor.$Revision: I struck another error from fetching program - $Val" ;;
              esac
                ;;
            esac 
          else
    # To make this work for ls -l, we'd have to pipe this through awk or cut, printing off the fourth field
    # Also, ls -l makes for WAY more data than just ls
# ZD: cat on the same line as grep is a nono, grep blah file instead
            MAXREMOTEVAL=$(grep "rfc[[:digit:]]*.txt" $DIRLIST 2>/dev/null | cut -c4- | sort -n | tail -n 1 | cut -d. -f1 )
            echo $MAXREMOTEVAL
            read mumble
        fi
  # then, grab the largest number from the latest available downloaded list
    else
        $MyDialog --title "$ME-$Minor.$Revision: error" --msgbox "I cannot download filelist, you don't have\n\
ncftp3, curl, lynx, or wget installed" 11 50
    fi
}

#########################################################################
# a routine that checks the remote file's size against local version
# giving us RemoteSize1-3 as remote sizes, LocalSize1-3 as local sizes
# and compares them, replying with a string "build" of files to download
#########################################################################

CheckSize() {
# This fetches three file's sizes from our remote site.
# It only fetches rfc doc indexes
######################### WARNING ####################################
# This is VERY sensitive to the client we use, so I'm expecting bugs here
# it can also be replaced by curl using -I
# Another thing is the timeouts...
# We also now rely on expect being present - if it's not, then we can't
# go ahead, and have to fetch files regardless.
######################### WARNING ####################################
    if [ "$MYGET" -a "$MYGET" = "$MYNCGET" ]; then
        MyExpect=$(type -p expect 2>/dev/null)
        if [ -z $MyExpect ]; then
            build="-index -ref xx00 "
        else
# Routine begins ...
            MyRemoteSize=$(\
                $MyExpect -c \
"spawn ncftp -u anonymous -p $USER@$HOSTNAME $REMOTEPLACE;\
set timeout $CONTACT_TIMEOUT; \
expect \"/in-notes > \"; \
set timeout 25; \
send \"bin\n\"; \
expect \"/in-notes > \"; \
send \"quote size $RFC_FILE1\n\"; \
send \"quote size $RFC_FILE2\n\"; \
send \"quote size $RFC_FILE3\n\"; \
expect \"/in-notes > \"; \
send \"set confirm-close no\n\"; \
send \"close\n\"" | tail -6 | tr -d '\015')
# ... and expect routine ends
            RemoteSize1=$(echo "$MyRemoteSize" | head -1)
            RemoteSize2=$(echo "$MyRemoteSize" | tail -4 | head -1)
            RemoteSize3=$(echo "$MyRemoteSize" | tail -2 | head -1)
            SizeRemoteLocal
        fi # finishes off the "if 'expect' exists" loop
 # Finishes the "do we even HAVE a ncftpget" loop.
    elif [ "$MYGET" -a "$MYGET" = "$MYCURL" ]; then
# we can get the filesizes directly with curl
        if [ "$FORMAT" = "rfc" ]; then
          MyStatus "Fetching sizes of rfc files"
          RemoteSize1=$(curl -I $REMOTEPLACE$RFC_FILE1 2>/dev/null | grep "Length" | cut -d: -f2 | tr -d '\015' )
          RemoteSize2=$(curl -I $REMOTEPLACE$RFC_FILE2 2>/dev/null | grep "Length" | cut -d: -f2 | tr -d '\015' )
          RemoteSize3=$(curl -I $REMOTEPLACE$RFC_FILE3 2>/dev/null | grep "Length" | cut -d: -f2 | tr -d '\015' )
          SizeRemoteLocal
        else
          MyStatus "Fetching size of $FORMAT-index"
          RemoteSize1=$(curl -I $REMOTEPLACE$FORMAT/$FORMAT-index.txt  2>/dev/null | grep "Length" | cut -d: -f2 | tr -d '\015' )
          RFCFile="$FORMAT-index"
          GoCat > $MYFILE
          LocalSize1=$(ls -l $MYFILE | cut -d' ' -f6)
          if [ "$LocalSize1" -ne "$RemoteSize1" ]; then
            build="$FORMAT-index "
            MyStatus "Sizes differ, adding $build to the download list"
          fi
        fi
    else
        $MyDialog --title "$ME-$Minor.$Revision: error" --msgbox "I cannot download filelist, you don't have\n\
ncftp3, or curl installed" 11 50
# ncftp3, curl, lynx, or wget installed" 11 50
    fi # End of "if myget=mycurl" || if myget=myncget || puke
}

############################################################
# This routine compares our sizes with their remote cousins
############################################################

SizeRemoteLocal() {
# * Now that we have the remote sizes, what about our copies (if any)?
#   First, we have to GoCat into a temp file, to get the uncompressed size
# !  We've struck a possible bug with ls not always supporting -l
########################
    RFCFile="$FORMAT-index"
    GoCat > $MYFILE
    LocalSize1=$(ls -l $MYFILE | cut -d' ' -f6)
    RFCFile=-"$FORMAT-ref"
    GoCat > $MYFILE
    LocalSize2=$(ls -l $MYFILE | cut -d' ' -f6)
    RFCFile="${FORMAT}xx00"
    GoCat > $MYFILE
    LocalSize3=$(ls -l $MYFILE | cut -d' ' -f6)
# now we clean up after ourselves
# ZD: Now this shows how dangerous rm -rf can be, what if MYFILE for *SOME* reason is $HOME ?
# EG: MYFILE is NEVER $HOME, it's always /tmp/rfctemprfc, as shown at the top
#     of the file 8-)
# ZD: then you're in trouble, or /? It'll start removing stuff carelessly
    rm -f $MYFILE
    if [ "$LocalSize1" -ne "$RemoteSize1" ]; then
        build="-index "
    fi
    if [ "$LocalSize2" -ne "$RemoteSize2" ]; then
        build="$build -ref "
    fi
    if [ "$LocalSize3" -ne "$RemoteSize3" ]; then
        build="$build xx00 "
    fi
    # Now, I need to sort out what the hey is going on
}

# New function to hopefully fetch all the latest rfc docs
# TODO: Weakness is: it depends upon $DIRLIST having already been fetched, and 
#       that it is also the latest available.

FetchLatest() {
  MYLINES=10
  MyNotify "We're getting the $FORMAT list. \n
  This'll take a wee while, please wait after hitting Enter"
    CheckSize  
# The idea here is that we go from our latest to their latest, and try to download everything in between
# Of course, we could pass in a value to download FROM and TO.
# Theoretically, if $build is empty, should we even download a listing? 
# Yes we should, if we don't have everything they have.
#+ Now we choose whether we're getting rfc, bcp, fyi or std: Format()
#    Format
#    FORMAT="rfc" # This is a default until I correctly write the rest
# This calls CheckSize, which then calls SizeRemoteLocal
# if we're working with $FORMAT=rfc, else we just set $build to -index
  ParseLatestList
  case $FORMAT in 
    rfc)
    if [ "$MAXVAL" != "$MAXREMOTEVAL" ]; then # note that we do none of this if both values match
# ! This test should change, because of us missing files that remoteplace has
# * We now have a new routine for checking sizes of remote files - provides $build
#   realistically, we step backwards by 120 just to catch the stragglers we don't yet have,
#   or go from 1 if we have less than rfc120.*  Only thing this doesn't catch is when we have
#   rfc docs lots later than 120 (like rfc3905 but nothing earlier)
#   We should only download if RemoteSize != LocalSize
        if [ "$MAXVAL" > 120 ]; then
            BOTTOM=$(( $MAXVAL - 120 ))
        else
            BOTTOM=1
        fi
        for this in $build $(seq $BOTTOM 1 $MAXREMOTEVAL); do
          MyStatus "checking..."
          ############## rfc/std/bcp/fyi-dependent #############
          REMOTEFILE="$FORMAT""$this".$DEFEXT
          ############## rfc/std/bcp/fyi-dependent #############
          grep ^$REMOTEFILE $FORMAT$DIRLIST
          if [ "$?" = 0 ]; then
            FetchSingle
          else
      #we can't download this one, continue on
            MyStatus "$REMOTEFILE not available, continuing on"
          fi
        done
    else
      if [ "$build" ]; then
        MyStatus "Build was $build, now we got to fetch them, and catch up"
        if [ "$MAXVAL" > 120 ]; then
            BOTTOM=$(( $MAXVAL - 120 ))
        else
            BOTTOM=1
        fi
        for this in $build $(seq $BOTTOM 1 $MAXREMOTEVAL); do
          MyStatus "checking..."
          ############## rfc/std/bcp/fyi-dependent #############
          REMOTEFILE="$FORMAT""$this".$DEFEXT
          ############## rfc/std/bcp/fyi-dependent #############
          mumble=$(grep ^$REMOTEFILE $FORMAT$DIRLIST | tr -d '\015')
          if [ "$?" = 0 ]; then
            FetchSingle
          else
      #we can't download this one, continue on
            MyStatus "$REMOTEFILE not available, continuing on"
          fi
        done
      fi # end of "if [ $build ]; " loop
    fi
    # Okay, that got stuff _IF_ MAXREMOTEVAL != MAXVAL. Now, what about stuff that snuck in
    # under the MAXVAL radar?
    ;;
    bcp)
      if [ "$MAXBCPVAL" != "$MAXREMOTEBCPVAL" ]; then # note that we do none of this if both values match
  # This test should change, because of us missing files that remoteplace has
# * We now have a new routine for checking sizes of remote files - provides $build
# realistically, we step backwards by 120 just to catch the stragglers we don't yet have,
# or go from 1 if we have less than rfc120.*  Only thing this doesn't catch is when we have
# rfc docs lots later than 120 (like rfc3905 but nothing earlier)
# We should only download if RemoteSize != LocalSize
        if [ "$MAXBCPVAL" > 100 ]; then
          BOTTOM=$(( $MAXBCPVAL - 100 ))
        else
          BOTTOM=1
        fi
        for this in $build $(seq $BOTTOM 1 $MAXREMOTEBCPVAL); do
          MyStatus "checking..."
          ############## rfc/std/bcp/fyi-dependent #############
          REMOTEFILE="$FORMAT""$this".$DEFEXT
          ############## rfc/std/bcp/fyi-dependent #############
          grep ^$REMOTEFILE $FORMAT$DIRLIST
          if [ "$?" = 0 ]; then
            FetchSingle
          else
      #we can't download this one, continue on
            MyStatus "$REMOTEFILE not available, continuing on"
          fi
        done
    fi
    ;;
    fyi)
      if [ "$MAXFYIVAL" != "$MAXREMOTEFYIVAL" ]; then # note that we do none of this if both values match
  # This test should change, because of us missing files that remoteplace has
# * We now have a new routine for checking sizes of remote files - provides $build
# realistically, we step backwards by 120 just to catch the stragglers we don't yet have,
# or go from 1 if we have less than rfc120.*  Only thing this doesn't catch is when we have
# rfc docs lots later than 120 (like rfc3905 but nothing earlier)
# We should only download if RemoteSize != LocalSize
        if [ "$MAXFYIVAL" > 12 ]; then
            BOTTOM=$(( $MAXFYIVAL - 12 ))
        else
            BOTTOM=1
        fi
        for this in $build $(seq $BOTTOM 1 $MAXREMOTEFYIVAL); do
          MyStatus "checking..."
          ############## rfc/std/bcp/fyi-dependent #############
          REMOTEFILE="$FORMAT""$this".$DEFEXT
          ############## rfc/std/bcp/fyi-dependent #############
          grep ^$REMOTEFILE $FORMAT$DIRLIST
          if [ "$?" = 0 ]; then
            FetchSingle
          else
      #we can't download this one, continue on
            MyStatus "$REMOTEFILE not available, continuing on"
          fi
        done
    fi
    ;;
    std)
      if [ "$MAXSTDVAL" != "$MAXREMOTESTDVAL" ]; then # note that we do none of this if both values match
  # This test should change, because of us missing files that remoteplace has
# * We now have a new routine for checking sizes of remote files - provides $build
# realistically, we step backwards by 120 just to catch the stragglers we don't yet have,
# or go from 1 if we have less than rfc120.*  Only thing this doesn't catch is when we have
# rfc docs lots later than 120 (like rfc3905 but nothing earlier)
# We should only download if RemoteSize != LocalSize
        if [ "$MAXSTDVAL" > 20 ]; then
            BOTTOM=$(( $MAXSTDVAL - 20 ))
        else
            BOTTOM=1
        fi
        for this in $build $(seq $BOTTOM 1 $MAXREMOTESTDVAL); do
          MyStatus "checking..."
          ############## rfc/std/bcp/fyi-dependent #############
          REMOTEFILE="$FORMAT""$this".$DEFEXT
          ############## rfc/std/bcp/fyi-dependent #############
          grep ^$REMOTEFILE $FORMAT$DIRLIST
          if [ "$?" = 0 ]; then
            FetchSingle
          else
      #we can't download this one, continue on
            MyStatus "$REMOTEFILE not available, continuing on"
          fi
        done
    fi
    ;;
  esac
}

FetchSingle() {
# This routine checks to see if we have it, how about spinning that off to a separate function,
# much like TestItsHere is supposed to do? We should really strip this function down to
# purely getting the file, maybe spinning off the compress stage to another function
  case $FORMAT in 
    fyi|bcp|std) THEREPLACE="${REMOTEPLACE}$FORMAT/"
    HEREPLACE="${PLACE}$FORMAT/"
    MyStatus "Mumble: $mumble; Fetching $REMOTEFILE, from $REMOTEPLACE$FORMAT"
    ;;
    rfc) THEREPLACE="$REMOTEPLACE"
    HEREPLACE="$PLACE"
    MyStatus "Mumble: $mumble; Fetching $REMOTEFILE, from $REMOTEPLACE"
    ;;
  esac
  MYLINES=11
  case "$REMOTEFILE" in
      $FORMAT-menu) MyNotify "Get REAL! That file doesn't exist up there" ;;
      $FORMAT-list) MyNotify "Get REAL! That file doesn't exist up there!" ;;
      ${FORMAT}-retrieval.txt|${FORMAT}-index.txt|rfc-ref.txt|rfcxx00.txt|rfc-index-latest.txt)
      # Should we replace the copy in $PLACE, $INDEX, or $WRITEABLE?
          $MYGET $MYGETPARM "$HEREPLACE$REMOTEFILE" "$THEREPLACE$REMOTEFILE" 
          retval=$?
          if [ $retval != "0" ]; then
              MyStatus "$ME-$Minor.$Revision: Can't get file, got error $retval - perhaps try again later?"
              sleep 2
          else
# Now we get rid of the old one...
# ! Also, what the hey do we do for non-compressed files?
            if [ "$MYCOMPRESS" ]; then
              MyStatus "$ME-$Minor.$Revision: Removing original compressed file..."
            fi
# need a wrapper around this. Ooops - we could conceivably delete the wrong one.
            if [ -f $HEREPLACE$REMOTEFILE.bz2 ]; then
              MyStatus "$HEREPLACE$REMOTEFILE.bz2"
              rm -f $HEREPLACE$REMOTEFILE.bz2
            elif [ -f $HEREPLACE$REMOTEFILE.gz ]; then
              MyStatus "$HEREPLACE$REMOTEFILE.gz"
              rm -f $HEREPLACE$REMOTEFILE.gz
            fi
# ! Now, what if it's a *.txt we're replacing? Oh, that's right. We
#   just obliterated it with the download 8-) and put the new one into place
# This line simply won't actually work when $MYCOMPRESS is empty
            if [ "$MYCOMPRESS" ]; then
              MyStatus "compressing downloaded document $HEREPLACE$REMOTEFILE"
              $MYCOMPRESS "$HEREPLACE$REMOTEFILE"
            fi
# All done, time to quit.
          fi
          ;;
      *.txt.pdf)
          if [ -f "$REMOTEFILE" ]; then
            # There's a question whether this should have been a Status or a Notify
            # I'll make it a Status instead, for now.
              MyStatus "FetchSingle: We already have $REMOTEFILE"
          else # Okay, we don't have it - so go get it
            # Status, or Notify? Notify gets in the way, Status never gets seen.
              MyStatus "Getting $REMOTEPDFPLACE$REMOTEFILE"
#                ncftpget -v "$REMOTEPLACE""pdfrfc/$REMOTEFILE" 
              $MYGET $MYGETPARM "$REMOTEPDFPLACE$REMOTEFILE" 2>&1 >>$STATUSFILE
              RetVal=$?
              if [ $RetVal != "0" ]; then
                  MyStatus "$ME-$Minor.$Revision: Can't get file, got error $RetVal - perhaps try again later?"
              else
                  MyStatus "Okay, got it now"
                  if [ "$this" -gt "$MAXVAL" ]; then
                      MAXVAL=$this
                  fi
              fi
          fi
          ;;
      *.pdf) # discrepancy here - there's *.pdf, and *.txt.pdf
          if [ -f "$REMOTEFILE" ]; then
              $MyDialog --title "$ME-$Minor.$Revision: notify" --msgbox "We already have $REMOTEFILE" 8 50
          else # Okay, we don't have it - so go get it
              MyStatus "Getting $THEREPLACE$REMOTEFILE - please wait"
              $MYGET $MYGETPARM "$THEREPLACE$REMOTEFILE" 2>&1 >>$STATUSFILE
              RetVal=$?
              if [ $RetVal != "0" ]; then
# ! Hmm, this doesn't work for fyi et al.
                  REMOTEFILE=rfc$this.txt.pdf
                  MyStatus "$ME-$Minor.$Revision: Can't get file, got error $RetVal - now trying $THEREPLACE""pdfrfc/$REMOTEFILE"
                  FetchSingle
              else
                  MyStatus "Okay, got $REMOTEFILE now"
                  if [ "$this" -gt "$MAXVAL" ]; then
                      MAXVAL=$this
                      MyStatus "Updating MAXVAL:$MAXVAL to $this"
                  fi
              fi
          fi
          ;;
      *) if [ -f "$HEREPLACE/$REMOTEFILE.bz2" ]; then
            MyStatus "We already have $REMOTEFILE.bz2"
          elif [ -f "$HEREPLACE/$REMOTEFILE.gz" ]; then
          MyStatus "$ME-$Minor.$Revision: We already have $REMOTEFILE.gz"
          elif [ -f "$HEREPLACE/$REMOTEFILE" ]; then
          MyStatus "$ME-$Minor.$Revision: We already have $REMOTEFILE"
          else # Okay, we don't have it - so go get it
          if [ "$MYGET" ]; then
              MyStatus "Getting $THEREPLACE$REMOTEFILE"
          $MYGET $MYGETPARM "$HEREPLACE$REMOTEFILE" "$THEREPLACE$REMOTEFILE" 2>&1 >>$STATUSFILE
          #    $MYGET $MYGETPARM "$THEREPLACE$REMOTEFILE" 
              RetVal=$?
# 'Nother random thought - how about a TellGet() to tell us what happened (if anything)?
# It'd be customised per invocation - i.e. curl returns differently than lynx/wget/ncftpget
              MYLINES=10
              if [ $RetVal != "0" ]; then
                MyNotify "Can't get file, got error $RetVal - perhaps try again later?"
              else
# We should only bzip2 if it's txt, not otherwise - could be conflict with *.txt.pdf, however, that's 
# covered in the above case
                  if [ "$DEFEXT" = "txt" ]; then
# ! What happens when $MYCOMPRESS doesn't have a value? (No gzip/bzip2)
                    MyStatus "Compressing $REMOTEFILE"
                      $MYCOMPRESS "$HEREPLACE$REMOTEFILE"
                  fi
# All done, time to quit. Should we update MAXVAL here if it's shifted?
# Also, this shouldn't BE a notify, as that's a blocking operation.
                  MyStatus "Okay, got $REMOTEFILE now"
                  if [ "$MAXVAL" ]; then
                    if [ "$this" -gt "$MAXVAL" ]; then
                      MAXVAL=$this
                      MyStatus "Updating MAXVAL:$MAXVAL to $this"
                    fi
                  else
                    MAXVAL=$this
                  fi
              fi
              shift # Now that we have it (or not), we can move on
          else 
              MYLINES=10
              MyError "I cannot download filelist, you don't have\n\
ncftp3, curl, lynx, or wget installed" 11 50
          fi
      fi
    ;;
  esac
} # End of FetchSingle

FetchRange() {
# Realistically, I can probably call FetchSingle for each item in range
# For THIS to work properly, $THAT absolutely MUST be valid on entry!
# ERROR: this doesn't work if we don't have a $DIRLIST downloaded, and
#        is incorrect if we don't have the latest dirlist.
# Besides which, if we're going to be fetching from the site, might as well get
# the most recent.
    Val=-get
    if [ -z "$GotDir" ]; then
# This is where we get that dir
      MYLINES=10
      MyNotify "This'll take a wee while, please wait after hitting Enter"
      # I'm not sure about whether this is correct/needed, so I'm going with a guess.
      CheckSize
      ParseLatestList
    fi
# ZD: Use meaningful variable names
    for ((this=$THIS;this<=$THAT;this++)); do
        REMOTEFILE=$FORMAT"$this".$DEFEXT
  # We recurse... why not? And by now, we ought to have a DirList
        mumble=$(grep ^$REMOTEFILE $FORMAT$DIRLIST)
        if [ "$?" = 0 ]; then
            FetchSingle
        else
    #we can't download this one, continue on
            MyStatus "$REMOTEFILE not available, continuing on"
        fi
    done
}

FetchCore() {
#########################################################
# Central dispatch for getting stuff, one, many or latest
# Talks to FetchSingle, FetchCore, ParseLatest, and a
# couple of other routines
# One important thing: what dir are we in?
#########################################################
    case $Q in
        -get|--get)
    # ! This should be restricted to those that have write permission
    #   to the dir the rfcs are held in. At the moment, we don't CHECK write permission
    
            if [ "$MYGET" ]; then
                THIS=$( echo $REST | cut -d' ' -f1 )
                this=$THIS
                REMOTEFILE=$FORMAT$this.$DEFEXT
# We have to be in a writeable dir before we allow downloading
                if [ "$WRITEABLE" ]; then
                  MyStatus "Writable=$WRITEABLE"
                    TestItsHere # checks it's in $PLACE
                    # Maybe we ought to provide a --force switch for this
                    if [ "$NOTHERE" = "0" ]; then # We've found it
                        MyStatus "We have $REMOTEFILE stored in $mumble already"
                      # fetch if we force it
                        if [ $FORCEGET ]; then
                          FetchSingle
                        fi
                    else # check the other dir to see if it exists already
                        OLDPLACE=$PLACE
                        PLACE=$WRITEABLE
                        cd $PLACE
                        TestItsHere
                        if [ "$NOTHERE" = "0" ]; then
# We've found it
#                            echo "We have $REMOTEFILE, stored in ${PLACE}$mumble already"
                            MyStatus "We have $REMOTEFILE stored in $mumble already"
                        else
                            FetchSingle # this is in $WRITEABLE now
# Now, do we need to update MAXVAL? We can't do it here, as FetchSingle handles both success and failure
# ... so, we have to do it within FetchSingle
                        fi
                        cd $OLDPLACE
# We have it already, no need to download, msg user to say so
                    fi
# This fails the "check it's here already in $OLDPLACE" test
                else # bitchmoan
                    MyError "I can't download to $PLACE. You don't have permission to write to the directory."
                fi
            else
                MyError "I cannot download filelist, you don't have ncftp3, curl, lynx, or wget installed"
            fi # End of "if $myget"
            ;;
        -getrange|--getrange)
            THIS=$( echo $REST | cut -d' ' -f1 )
            THAT=$( echo $REST | cut -d' ' -f2 )
            if [ "$WRITEABLE" ]; then
                FetchRange
            else # bitchmoan
              MyError "I can't download to $PLACE. You don't have permission to write to the directory."
            fi
            ;;
        -getlatest|--getlatest)
            if [ "$WRITEABLE" ]; then
                FetchLatest
            else # bitchmoan
              MyError "I can't download to $PLACE. You don't have permission to write to the directory."
            fi
            ;;
        -version|--version|-v)
            echo "I am $ME, revision $Minor.$Revision"
            menulevel=0
            ;;
        *) 
    #ZD: could be more informative
            echo "Why am I here in FetchCore? You fed me $Q: Hit Enter to continue"
            read mumble
            ;;
    esac
}

################## End of fetching code #########################


# This is the new code to replace all the previous code in the previous func.
# (... whatever that was called...)
ParseSwitch() {
    case $Q in
# Fetch
        --get|-get|--getrange|-getrange|--getlatest|-getlatest) 
            #Format # took it out of here, because I've put it in at the 
            # TaskSelect() place instead
            Val=$Q
            FetchCore
            ;;
        --forceget)
            FORCEGET=1
            ;;
# Toggle
        -pdf|-ps|-txt|-stdout)
            DEFEXT=$(echo $Q | cut -c2- )
            if [ "$DEFEXT" = "stdout" ]; then
                STDOUT=1
                DEFEXT=txt
            fi
            ;;
        --pdf|--ps|--txt|--stdout)
            DEFEXT=$(echo $Q | cut -c3- )
            if [ "$DEFEXT" = "stdout" ]; then
                STDOUT=1
                DEFEXT=txt
            fi
            ;;
        --no|-no) # tells me you don't want to create a writeable dir to download to
            NOMAKELOCALDIR=1
            ;;
        --consoledialog)
          ConsoleDialog=1
        ;;
        --version|-v|-version)
            Val=$Q
            FetchCore
            ;;
        --debug)
            debug_set=1
            ;;
# Prompt
        --menu|-menu)
 # This is the little weenie I need to troubleshoot - it seems $menulevel
 # gets set from TaskSelect, but not otherwise. So let's go set it from main
 # I don't yet know what the weak point is of this.
 # Let's try format BEFORE the MenuCore
            Format
            MenuCore
            if [ "$menulevel" -gt "1" ]; then
                RenderCore
                menulevel=1
            fi
            ;;
        --itemlist|-itemlist)
          ItemList
          if [ "$retval" -eq 0 ]; then
            RenderCore
          else
            menulevel=0
          fi
          ;;
        --front|-front)
            TaskSelect
            ;;
        --exit|-exit)
# This could break the "single exit" rule
            MyStatus "Leaving! Goodbye and thank you for running rfcshow"
            exit
            ;;
        fyi-index) 
        FORMAT=fyi
        HEREPLACE="${PLACE}$FORMAT"
        Val=-index
            RenderCore
          ;;
        bcp-index) 
        FORMAT=bcp
        HEREPLACE="${PLACE}$FORMAT"
        Val=-index
            RenderCore
          ;;
        std-index) 
        FORMAT=std
        HEREPLACE="${PLACE}$FORMAT"
        Val=-index
            RenderCore
          ;;
        rfc-index) 
        FORMAT=rfc
        HEREPLACE="${PLACE}"
        Val=-index
            RenderCore
            ;;
        --prompt|-prompt)
        # Let's stick this here, instead of before ParseSwitch
            Format
            PromptForNumber Number # returns number in Val            
            DeadYet
            if [ "$menulevel" -gt 0 ]; then
                MYLINES=$MYY
                PREVREST="$REST"
                REST="$( echo $Val| cut -d' ' -s -f2- ) $REST"
                AllVal="$Val"
                Val="$( echo $AllVal | cut -d' ' -f1 )"
#    $MyDialog --title "$ME-$Minor.$Revision:1 debug" --msgbox "Val: $Val\n\
#AllVal: $AllVal" 11 60
                while [ "$Val" ]; do
                  AllVal=$(echo $AllVal | cut -d' ' -s -f2-)
                  Q="$Val"
# This works when we don't pass through switches...
# When we pass through switches, it acts on those, but doesn't
# properly pop off the args TO those switches, so I had to build
# in another looping
                  ParseSwitch
                  case $Val in
                   -range|--range) 
                      Val="$( echo $AllVal | cut -d' ' -f4 )"
                   ;;
                   *)
                      Val="$( echo $AllVal | cut -d' ' -f2 )"
                   ;;
                  esac
#    $MyDialog --title "$ME-$Minor.$Revision:2 debug" --msgbox "Val: $Val\n\
#AllVal: $AllVal" 11 60
                done
  # Now that we've finished, let's restore the original
                REST="$PREVREST"
                Q=--prompt
            fi # end of "if menulevel > 0" test
            ;;
# Render
        --help|-help|-h|"-?")
#            RfcHelp > $MYFILE
#            MYLINES=$MYY
            Help
            HelpDeadYet
            until [ "$noexit" -eq 0 ]; do
              RfcEngine
              # we want to remain in this menu until we explicitly leave it
              # except it's not working for some silly reason
              Help
              HelpDeadYet
            done
            menulevel=1
            noexit=1
            ;;
        --listall|-listall|--list|-list) # I gave up on the idea of only showing 
# *.DEFEXT
# 'nother idea is that we prompt for mask, show those files only. <Enter> means *
            for this in $( ls  rfc[[:digit:]]*.txt* rfc{-index,-ref,xx00}.txt* rfc[[:digit:]]*.p{df,s}  | cut -c4- | sort -n ); do
                echo "rfc$this"; done > $MYFILE 2>/dev/null
            MASK=$(dialog --title "$ME-$Minor.$Revision: query" --inputbox "Filemask" 11 "$MYX" "*" 2>&1 1>$(tty))
            grep "rfc$MASK.*" $MYFILE > $MYFILE2
            mv -f $MYFILE2 $MYFILE
            column $MYFILE > $MYFILE2
            mv -f $MYFILE2 $MYFILE
            MYLINES=$MYY
            RfcEngine
            ;;
        --search|-search)
        # I wonder what would happen if we decided to search
        # the individual indexes instead of the master index?
        Format
  # if we don't have a $2, then we should prompt for it
            if [ -z "$2" ]; then
                keyword=$($MyDialog --title "$ME-$Minor.$Revision: query" --inputbox "Search Term" 11 "$MYX" 2>&1 1>$(tty))
                retval=$?
                DeadYet
            else
                keyword="$2"
            fi
            Search
            mumble=$(( $(cat $MYFILE | wc -l ) + 7 ))
            if [ "$MYY" -lt "$mumble" ]; then
                MYLINES=$MYY
            else
                MYLINES=$mumble
            fi
  # We gotta go build VarArray from that file BEFORE we delete the damn thing
  # That's going to be tricky
            VarArray=( $(cat $MYFILE) )
  # Okay, if we have no returns, we should say so.
            if [ "${#VarArray[@]}" -lt 1 ]; then
                MyError "Sorry, no results found"
              else
#  RfcEngine
  # now we present the user with a set of RFCs to go read.
                ChooseList
            fi
            ;;
        --searchtitles|-searchtitles)
  # if we don't have a $2, then we should prompt for it
            if [ -z "$2" ]; then
                keyword=$($MyDialog --title "$ME-$Minor.$Revision: query" --inputbox "Search Term" 11 "$MYX" 2>&1 1>$(tty))
                retval=$?
                DeadYet
            else
                keyword="$2"
            fi
            Format
            SearchOrig
            mumble=$(( $(cat $MYFILE | wc -l ) + 7 ))
            if [ "$MYY" -lt "$mumble" ]; then
                MYLINES=$MYY
            else
                MYLINES=$mumble
            fi
  # We gotta go build VarArray from that file BEFORE we delete the damn thing
  # That's going to be tricky
            VarArray=( $(cat $MYFILE) )
  # Okay, if we have no returns, we should say so.
            if [ "${#VarArray[@]}" -lt 1 ]; then
                $MyDialog --title "$ME-$Minor.$Revision: error" --msgbox "Sorry, no results found" 11 35 2>&1 1>$(tty)
  # now we present the user with a set of RFCs to go read.
            fi
            RfcEngine
            ;;
        --title|-title)
  # if we don't have a $2, then we should prompt for it
            Q=--title
            Format
            if [ -z "$2" ]; then
                PromptForNumber TitleSearch
                DeadYet
                keyword=$Val
            else
                keyword="$2"
            fi
            SearchTitle
            mumble=$(( $(cat $MYFILE | wc -l ) + 7 ))
            if [ "$MYY" -lt "$mumble" ]; then
                MYLINES=$MYY
            else
                MYLINES=$mumble
            fi
            RfcEngine
            ;;
        -ref)
# We need to check both $INDEX and $WRITEABLE as well as $PLACE
            HEREPLACE=$PLACE
            FORMAT=rfc
            Val=$Q
            RenderCore
            ;;
# This switch could have REST 'shift'ed after each invocation
# That would remove the necessity of shifting at 'main' stage
# However, let's let the calling parent handle this for the moment.
        --range|-range)
          if [ -z "$SetFormatDone" ]; then
            Format
          fi
            PrevVal="$Val"
            THIS=$( echo $REST | cut -d' ' -f1 )
            THAT=$( echo $REST | cut -d' ' -f2 )
            for ((this=$THIS;this<=$THAT;this++)); do
                Val=$this
                RenderCore
            done
            Val="$PrevVal"
            unset SetFormatDone
            ;;
        '') TaskSelect ;;
        --index|-index) 
        Val=-index
        MYLINES=$MYY
        Format
        RenderCore
        ;;
        # Note that these are NOT the indexes
        -std) FORMAT=std
        HEREPLACE="${PLACE}$FORMAT"
        THEREPLACE=$REMOTEPLACE$FORMAT
        ;;
        -bcp) FORMAT=bcp
        HEREPLACE="${PLACE}$FORMAT"
        THEREPLACE=$REMOTEPLACE$FORMAT
        ;;
        -fyi) FORMAT=fyi
        HEREPLACE="${PLACE}$FORMAT"
        THEREPLACE=$REMOTEPLACE$FORMAT
        ;;
        -rfc) FORMAT=rfc
        HEREPLACE="${PLACE}"
        THEREPLACE=$REMOTEPLACE
        ;;

        *) # We're going to assume (perhaps incorrectly) that we now only have numbers left
# Actually, this doesn't work in the case of -index/-ref/xx00 - they'll only be
# looked for in $PLACE
            Val="$Q"
            # This removes any "rfc" or "0" prefixed to the element
            ZeroStrip
            MYLINES=$MYY
            RenderCore
            ;;
    esac
}

ItemList() {
  MYLINES=15
  # Should we include the other three indices here too? (fyi, bcp, std?)
  # Alternative way of assigning an array especially for pdksh/zsh is: 
  # munchstring[task++]="first string"; munchstring[task++]="second string"; ....
  munchstring=("-index" "bcp/fyi/rfc/std-index" "on" "-ref" "rfc-ref" "off" "xx00" "rfcxx00" "off" "-instructions" "rfc-instructions" "off" "-retrieval" "bcp/fyi/rfc/std-retrieval" "off" )
  Val=$($MyDialog --title "Supplied RFCs" --radiolist "Select for viewing" "$MYLINES" 80 $(( $MYLINES - 7 ))  "${munchstring[@]}"  2>&1 1>$(tty))
  retval=$?
  # We need to put in a condition test here, for std/fyi/bcp don't have -ref,
  # -instructions, nor xx00
  case $Val in 
    -index|-retrieval)
      Format
    ;;
    -ref|xx00|-instructions)
      FORMAT=rfc
      HEREPLACE=$PLACE
      THEREPLACE=$REMOTEPLACE
    ;;
  esac
  MYLINES=$MYY
}


ZeroStrip() {
# This strips off zeros off the front of the parameter, and also removes 
# prepended 'rfc'
#  Val=$(echo $Val | sed 's/^rfc//')
  Val=$(echo $Val | sed 's/^0\+//')
}

BugAuthor() {
    echo "Oy! He hasn't coded $@ yet! Bug him! Hit Enter to continue..."
    read mumble
}

GoCat() {
# This routine finds a file, cats it to stdout if present
#echo "DefExt: $DEFEXT; HEREPLACE/RFCFile.DEFEXT:  $HEREPLACE/$RFCFile.$DEFEXT"
    case $DEFEXT in 
        pdf) 
            if [ -f $HEREPLACE/$RFCFile.$DEFEXT.bz2 ]; then
                bzcat $HEREPLACE/$RFCFile.$DEFEXT.bz2
            elif [ -f $HEREPLACE/$RFCFile.txt.pdf.bz2 ]; then
                bzcat $HEREPLACE/$RFCFile.txt.pdf.bz2
        # This finds both .txt.gz and .ps.gz
            elif [ -f $HEREPLACE/$RFCFile.$DEFEXT.gz ]; then
                zcat $HEREPLACE/$RFCFile.$DEFEXT.gz
            elif [ -f $HEREPLACE/$RFCFile.txt.$DEFEXT.gz ]; then
                zcat $HEREPLACE/$RFCFile.txt.$DEFEXT.gz
            elif [ -f $HEREPLACE/$RFCFile.$DEFEXT ]; then
                cat $HEREPLACE/$RFCFile.$DEFEXT
            fi
            ;;
        txt)
            if [ -f $HEREPLACE/$RFCFile.$DEFEXT.bz2 ]; then
                bzcat $HEREPLACE/$RFCFile.$DEFEXT.bz2
            elif [ -f $HEREPLACE/$RFCFile.txt.bz2 ]; then
                bzcat $HEREPLACE/$RFCFile.txt.bz2
        # This finds both .txt.gz and .ps.gz
            elif [ -f $HEREPLACE/$RFCFile.$DEFEXT.gz ]; then
                zcat $HEREPLACE/$RFCFile.$DEFEXT.gz
            elif [ -f $HEREPLACE/$RFCFile.$DEFEXT ]; then
                cat $HEREPLACE/$RFCFile.$DEFEXT
            fi
            ;;
        ps)
            if [ -f $HEREPLACE/$RFCFile.$DEFEXT.bz2 ]; then
                bzcat $HEREPLACE/$RFCFile.$DEFEXT.bz2
            elif [ -f $HEREPLACE/$RFCFile.txt.bz2 ]; then
                bzcat $HEREPLACE/$RFCFile.txt.bz2
        # This finds both .txt.gz and .ps.gz
            elif [ -f $HEREPLACE/$RFCFile.$DEFEXT.gz ]; then
                zcat $HEREPLACE/$RFCFile.$DEFEXT.gz
            elif [ -f $HEREPLACE/$RFCFile.$DEFEXT ]; then
                cat $HEREPLACE/$RFCFile.$DEFEXT
            fi
            ;;
    esac
}

# Borrowed a bit of perl code from the other rfc program out there,
# Thanks to the author, Derrick Daugherty.
#############################################################################
# v3.2  Needs perl5 and w3m/lynx; edit path above to the location of your perl
#       install. Run as root the first time to setup the index
#       or change $indexpath
# This is a work in progress but i'm really happy with how easy it's
# made my life.   Written by Derrick Daugherty  freix/sifr  #unixgods /
# #solaris efnet.  bug fixes/suggestions mail me at rfc@dewn.com
#############################################################################
#              TO DO
# add diff url for html (-l) and txt's for -m/d/o etc
# add element to array for diff sites if they have leading 00's or not
# obey $PAGER?
# add extension for BCP/STD/FYI related rfc's only
# Add ICMP types
# clean up and optimize some
#
#############################################################################
# Feel free to redistribute as long as you keep this header in tact.
# http://www.dewn.com/rfc/
# Please let me know if you find this useful, I'd love to hear about it!
# rfc@dewn.com
#############################################################################
# ECG:
# We can build on this routine later, grabbing an array of
# returned results, and sequentially displaying them.
# Or, we could select with radio boxes.
# * We've found a weakness here - we have to take out ( Format TXT=41132 )
#   responses for a purely numeric input (4113), for example.
# I've got a crude setup for sed working already

Search() {
# First, we have to have an index to search...
# Coma mentioned this ought to work for gz too
# Perhaps a routine like GoCat() > $MYFILE?
# HEREPLACE has already been set by Format
#    HEREPLACE=$PLACE
#    RFCFile=rfc-index
      RFCFile=$FORMAT-index
# How about changing to $INDEX first? That would handle well.
#cd $INDEX
    GoCat > $MYFILE
    indexpath=$MYFILE
# $lookingfor ought to be passed into this routine, or else
# it simply won't work.
    perl -e '
  {
    $RFCIndex = $ARGV[0];
#	my $RFCIndex = @ARGV[0];
	shift @ARGV;
    my $search_str = uc(join " ", @ARGV);
    open(my $RFCINDEX, q(<), $RFCIndex) or die "Unable to open rfc-index.txt for reading: $!";
    <$RFCINDEX> for 1 .. 68;
    my @match;
    {
        # paragraph mode
        local $/ = "";
        while (<$RFCINDEX>) {
            tr/\r\n/  /;
            s/\s+/ /;
			push @match, (split /\W+/, $_)[0] if index(uc($_), $search_str) != -1;
        }        
    }
	my $SearchText = join " ", @match;
    print $SearchText;
}' $MYFILE "${keyword}" > $MYFILE2
# No need for the index any more, might as well replace it with our target results
    mv -f $MYFILE2 $MYFILE
# Here, we had better build VarArray for later ChooseList() function
#cd $PLACE
}

SearchTitle() {
#    HEREPLACE=$PLACE
    RFCFile=$FORMAT-index
#cd $INDEX
    GoCat > $MYFILE
    indexpath=$MYFILE
    perl -e '
    $indexpath = $ARGV[0];
    shift @ARGV;
    $_ = join " ", @ARGV;
    if (int($_) and ($_ =~ /^\d+$/) ) {
       $grepmod = int($_);
    }
    my $numdigits = length($grepmod);
    while ($numdigits < 4) {
       $grepmod = "0" . $grepmod;
       $numdigits++;
    }
    $caretmod = "^$grepmod";
open (RFCINDEX, $indexpath);
  # This will get us where we are going...
  while (<RFCINDEX>) {
  #next if (!/^$grepmod/);
  next if (!/$caretmod/);
  # Heres where Id have to recover the first part of the line
  print "$_";
  last; }
  # Roll through the rest of the lines and print.
  while (<RFCINDEX>) {
  last if (/^$/);
  print; 
}
close (RFCINDEX);
' $MYFILE $keyword > $MYFILE2
    mv -f $MYFILE2 $MYFILE
#cd $PLACE
}

SearchOrig() {
# First, we have to have an index to search...
# Coma mentioned this ought to work for gz too
# Perhaps a routine like GoCat() > $MYFILE?
#    HEREPLACE=$PLACE
    RFCFile=$FORMAT-index
# How about changing to $INDEX first? That would handle well.
#cd $INDEX
    GoCat > $MYFILE
    indexpath=$MYFILE
# $lookingfor ought to be passed into this routine, or else
# it simply won't work.
    perl -e '
  {
    my $filename = $ARGV[0];
    shift @ARGV;
    my ($thing,$line,$first_word);
    my $found = 0;
    my $rfccount = 0;
    my @rfclist;
    my ($lookingfor) = join " ", @ARGV;
    print "The Result:\n";
    open (RFCINDEX, $filename);
    # How do we jump over the initial paragraphs? This just
    # starts at the beginning.
    foreach $line (<RFCINDEX>) 
    {
      if ($line !~ /^\s*$/){
        $thing .= $line; 
        # This is too simplistic, for example a search for mail
        # matches the prefacing paragraph before all the descs
        if ($line =~ /$lookingfor/i) {
          $found = 1;
          $rfccount++;
          # now, how do we recover first element of a line?
#          $first_word = (split /\W+/, $line)[0];
#          $first_word =~ s/^0+//;
        }
      }
     else { 
      if ($found) { 
      print $thing;
# This should have prepended "0" removed.
      print $first_word, " ";
                }
    $thing = ""; $found = 0;
    }
  }
    print "Found $rfccount results";
    close (RFCINDEX);
  }
' $MYFILE "$keyword" > $MYFILE2
# No need for the index any more, might as well replace it with our target results
    mv -f $MYFILE2 $MYFILE
# Here, we had better build VarArray for later ChooseList() function
#cd $PLACE
}

FeedQREST () {
    Q=$1
    shift
    REST=$@
}

############## trial code ###########################
##############################################################################
# Now we start the global code again... sorry about the break, folks.
##########
# main
#declare -a MYSIZE

##########
# size-related items
MYSIZE=$(stty size)
# Code here replaced by the later two lines, saves a cut call
#MYY=$( echo $MYSIZE | cut -f1 -d' ')
#MYX=$( echo $MYSIZE | cut -f2 -d' ')
# Two new lines, removes two calls to cut - may be dependent upon bash version
MYY=${MYSIZE% *}
MYX=$(( ${MYSIZE##* } - 2 ))
MYX=$( echo $(($MYX - 2 )) )
MYMINX=60
if [ $MYX -gt 78 ]; then
    MYLISTX=78
else
    MYLISTX=$MYX
fi
trap ReSize SIGWINCH
# end of size-related stuff.
#########
# Should I also trap Ctl-C too?
#########

noexit=1 # This is a noexit var - if it goes to 0, we leave. Simple, eh?
# Test for these two regardless
MyWHIPTAIL=$(type -p whiptail 2>/dev/null)
MyCDialog=$(type -p dialog 2>/dev/null)

# We make sure that we choose consoledialog even when X is selected
# if this switch is selected.
if [ "$1" == "--consoledialog" ]; then
  Q=$1
  ParseSwitch
  shift
fi
if [ $DISPLAY ]; then
	#ZD: Use xmsg
# To save time, I'll only look for a [x|g]dialog if we're on X
# The other thing is: zenity is now called by gdialog
    MyGDialog=$(type -p gdialog 2>/dev/null)
    MyXDialog=$(type -p Xdialog 2>/dev/null)
    MyKDialog=$(type -p kdialog 2>/dev/null)
    MyZenity=$(type -p zenity 2>/dev/null)
  # We can't give even preference, we have to choose one or the other
  # and frankly I don't like kdialog, but it's out there. I guess I'll
  # have to do some more testing.
  # Whoops - I have to figure out how to reset this
  if [ "$ConsoleDialog" ]; then
    MyDialog=${MyCDialog:-$MyWHIPTAIL}
  else
    MyWMDialog=${MyGDialog:-$MyKDialog}
  # Use Xdialog if we have neither Gdialog nor kdialog
    MyTestXDialog=${MyWMDialog:-$MyXDialog}
  # Use cdialog or whiptail if we have no X dialog
    MyTestCDialog=${MyCDialog:-$MyWHIPTAIL}
#    MyTestCDialog=${MyCDialog}
    MyDialog=${MyTestXDialog:-$MyTestCDialog}
  fi
else
    MyDialog=${MyCDialog:-$MyWHIPTAIL}
fi
# IS there a dialog on the system?

# This bit checks for whether we HAVE one...because if we DON'T
# then bad things are going to happen
if [ ! "$MyDialog" ]; then
    echo "$ME-$Minor.$Revision: uh oh! No gdialog/kdialog/Xdialog, and no dialog/whiptail program"
    echo "on this system. I have to bail now, sorry"
# I'm sure we can be forgiven for bailing early
    noexit=0
    Q=--exit
    ParseSwitch
fi
# Lines borrowed from somewhere else
# Interesting point - STDOUT hasn't even been SET here yet
# echo "Starting setup - hit Enter to continue"; read shyte
if [ "$STDOUT" ]; then
    echo "Please wait while I set up."
#else
#  if [ "$MyDialog" = "$MyKDialog" ]; then 
#    $MyDialog --title "$ME-$Minor.$Revision: Info" --msgbox "Hit Enter (or click OK) and wait while I set up" 7 30
#  else
#    $MyDialog --title "$ME-$Minor.$Revision: Info" --infobox "Please wait while I set up" 7 30
#  fi
fi
# Now, we see if the status file can be written to. If not, then we
# had better bail unless we can get a suitable file to write to.
############
# This should be the only time we need straight echos rather
# than log to status file; the user NEEDS to see this error.
if [ -e $STATUSFILE ]; then
  if [ ! -w $STATUSFILE ]; then
    echo "I can't write to $STATUSFILE, I'll have to exit.\n\
I'm out of here!" 12 50
    noexit=0
    Q=--exit
    ParseSwitch
  else
    echo "Opening status log: $(date +%c:%s)" >> $STATUSFILE
  fi
else # Not created yet
  touch $STATUSFILE
  retval=$?
  if [ "$retval" != 0 ]; then
    echo "I can't create $STATUSFILE, I'll have to exit.\n\
I'm out of here!" 12 50
    noexit=0
    Q=--exit
    ParseSwitch
  else
    echo "Opening status log: $(date +%c:%s)" >> $STATUSFILE
  fi
fi
sleep 1
# This isn't an error, so we don't bail
# mind you, I've forgotten lynx in this collection of programs
if [ -z "$MYGET" ]; then
  MYLINES=12
  MyNotify "Whoops - you don't have any program I can use\n\
to fetch files with! Go grab a copy of one of\n\
these programs, and install it:\n\
ncftp3, curl, or wget"
fi
# Errors for missing grep programs
if [ -z "$MYGREP" ]; then 
# we bail, regardless of if we have bzgrep/zgrep or not, as 
# these both use grep as a backend, and we use grep inside
# ,000 00, 0 and units display.
  MYLINES=12
    MyError "Whoops - you don't have any program I can use\n\
to grep files with! Go grab a copy of grep\n\
and install it:\n\
I'm out of here!"
    noexit=0
    Q=--exit
    ParseSwitch
# .. however, if we have grep, but no bzgrep/zgrep we bail
# This is really a catchall just in case the function definitions
# failed for some reason.
elif [ -z "$MYCGREP" ]; then
  MYLINES=12
    MyError "Whoops - you don't have any program I can use\n\
to grep compressed files with! Go grab a copy\n\
of bzgrep (comes with recent bzip2) or zgrep\n\
(comes with gzip) and install them:\n\
I'm out of here!"
    noexit=0
    Q=--exit
    ParseSwitch
fi
# ? Do we really need to make this mandatory?
if [ -z "$MYCOMPRESS" ]; then
  MYLINES=12
  MyError "Whoops - you don't have any program I can use\n\
to compress files with! Go grab a copy\n\
of bzip2 or gzip and install them:\n\
I'm out of here!"
    noexit=0
    Q=--exit
    ParseSwitch
fi
######################################################################
# This routine tests whether a dir can be read (exists, currently),
# also tests for writability.
# Returns mumble=1 if successful, dir in PLACE, and rfc-index location
# in INDEX
######################################################################
for item in "$@"; do
    if [ "$item" = "-no" ]; then
        NOMAKELOCALDIR=1
    fi
done
for TESTPLACE in $PLACES; do
  if [ -d "$TESTPLACE" -a -r "$TESTPLACE" ]; then
  # Small problem: the second time through, PLACE gets set to this, regardless
  # of the fact we may have found a readable PLACE already. It will only be
  # aggravated by additional entries in $PLACES
    PLACE=${PLACE:-$TESTPLACE} # set it if it's not already set...otherwise don't set it again.
  # We'll set this here to the /rfc dir.
    HEREPLACE=$PLACE
    PlaceIsSet=1
  # Okay, we've found one - now, can we write to it?
    if [ -w "$TESTPLACE" -a -z "$WRITEABLE" ]; then
    # this fails in the case where both global AND local dirs are writable...
    # as it will choose the global over the local.
    # This also means that we now have to choose up to two places to check for rfcs
    # While we're at it, we'd better change the place we check the index in.
    # This will (or ought to be) relevant for -ref,xx00 too.
      INDEX=$TESTPLACE
      WRITEABLE=$TESTPLACE
    fi
  fi
done
if [ ! "$PlaceIsSet" ]; then
  # We should now offer the user a chance to create their own rfc dir, as we've looked in a
  # number of places for likely content. We'd better make this a No by
  # default, so the user doesn't nuke stuff they have already
  # ! I've noticed that Kdialog shows the \n as \n, and doesn't decode them.
  if [ "$MyDialog" = "$MyKDialog" ]; then 
    dialogopt=""
  elif [ "$MyDialog" = "$MyGDialog" ]; then
    dialogopt=""
  else
    dialogopt="--defaultno "
  fi
    $MyDialog --title "$ME-$Minor.$Revision: question" $dialogopt --yesno "I haven't found a directory that you \
can read that has RFCs in.\
I've looked in these places here:\n\
  $PLACES,\n\
but I'm not finding what I want.\n\
Do you want to create the directory\n\
  $HOME/rfc\n
so you can download documents locally (y/N)" 16 50
    if [ "$?" = 0 ]; then
        mkdir $HOME/rfc
        ret=$?
        if [ "$ret" != "0" ]; then
            echo "ERROR: mkdir $HOME/rfc failed with return value: $ret"
      # read-only home dir? Hmmm...
            noexit=0
            Q=--exit
            ParseSwitch
        fi
        # Now we can put the rest of the dirs into place
        mkdir $HOME/rfc/fyi
        ret=$?
        if [ "$ret" != "0" ]; then
            echo "ERROR: mkdir $HOME/rfc/fyi failed with return value: $ret"
      # read-only home dir? Hmmm...
            noexit=0
            Q=--exit
            ParseSwitch
        fi
        mkdir $HOME/rfc/bcp
        ret=$?
        if [ "$ret" != "0" ]; then
            echo "ERROR: mkdir $HOME/rfc/bcp failed with return value: $ret"
      # read-only home dir? Hmmm...
            noexit=0
            Q=--exit
            ParseSwitch
        fi
        mkdir $HOME/rfc/std
        ret=$?
        if [ "$ret" != "0" ]; then
            echo "ERROR: mkdir $HOME/rfc/std failed with return value: $ret"
      # read-only home dir? Hmmm...
            noexit=0
            Q=--exit
            ParseSwitch
        fi
    # ZD: --end addition--
        PLACE="$HOME/rfc/"
        HEREPLACE="${PLACE}"
        MyStatus "We've set HEREPLACE to $HEREPLACE"
        INDEX=$HOME/rfc
        WRITEABLE=$HOME/rfc
####### Commented out section for testing ##########
#    else
# I'm sure you'll forgive me if I exit, though I could probably still run
# without downloading
#        noexit=0
#        Q=--exit
#        ParseSwitch
####### Commented out section for testing ##########
    fi
else
# We GOT one!
    if [ -z "$WRITEABLE" -a -z "$NOMAKELOCALDIR" ]; then
# Offer to create a dir so they can download their own
# This shouldn't be done until after we've tested all options for writability
# --defaultno doesn't work under FreeBSD's braindead dialog-0.4
      $MyDialog --title "$ME-$Minor.$Revision: query" --yesno "\
I've found Request For Comment (RFC) docs in\n\
  $PLACE, \n\
but you can't write stuff to that directory.\n\
Do you want me to create the directory\n
  $HOME/rfc\n\
so you can download documents locally (Y/n)" 14 50
      if [ "$?" = 0 ]; then
        mkdir $HOME/rfc
        ret=$?
        if [ "$ret" != "0" ]; then
          echo "ERROR: mkdir $HOME/rfc failed with return value: $ret"
        # read-only home dir? Hmmm...
            noexit=0
            Q=--exit
            ParseSwitch
        fi
        mkdir $HOME/rfc/bcp
        ret=$?
        if [ "$ret" != "0" ]; then
            echo "ERROR: mkdir $HOME/rfc/bcp failed with return value: $ret"
      # read-only home dir? Hmmm...
            noexit=0
            Q=--exit
            ParseSwitch
        fi
        mkdir $HOME/fyi
        ret=$?
        if [ "$ret" != "0" ]; then
            echo "ERROR: mkdir $HOME/fyi failed with return value: $ret"
      # read-only home dir? Hmmm...
            noexit=0
            Q=--exit
            ParseSwitch
        fi
        mkdir $HOME/std
        ret=$?
        if [ "$ret" != "0" ]; then
            echo "ERROR: mkdir $HOME/std failed with return value: $ret"
      # read-only home dir? Hmmm...
            noexit=0
            Q=--exit
            ParseSwitch
        fi
      fi
    fi
# Now we test if we're on a Debian system with RFC packages installed 
# - most likely if $PLACE="/usr/share/doc/RFC/links"
    if [ "$PLACE" = "/usr/share/doc/RFC/links" -a -z "$WRITEABLE" ]; then
# Their rfc-index.txt resides in the parent dir.
        INDEX="${PLACE}.."
    elif [ "$WRITEABLE" ]; then
# ... we use our writeable one, though we still have to check back at $PLACE if this one doesn't exist
        INDEX="$WRITEABLE"
    else
# We don't have Debian's RFC packages installed (or it's not Debian)
        INDEX="$PLACE"
    fi

# Start off in a well known dir
# This bugs when my /home/user/rfc dir has no files, and
# the global dir is writable by the user
    cd $PLACE
fi

declare -a D[]
declare -a C[]
if [ "$1" = "-notx" ]; then
    RFCRun=less
    shift
else
#  if [ $DISPLAY ]; then
#    RFCRun=gless
#  else
    RFCRun=less
#  fi
fi
#MAXVAL=4051 # Latest available rfc current to 12 Apr 2005, 
# however the code below works it nicely
StartMeUp "$(ls  rfc[[:digit:]]*.txt* 2>/dev/null | wc -l )"
MAXVAL=$(ls  rfc[[:digit:]]*.txt* 2>/dev/null | cut -c4-| sort -n | tail -n 1 | cut -f1 -d. )
cd bcp
MAXBCPVAL=$(ls bcp[[:digit:]]*.txt* 2>/dev/null | cut -c4-| sort -n | tail -n 1 | cut -f1 -d. )
cd ../fyi
MAXFYIVAL=$(ls fyi[[:digit:]]*.txt* 2>/dev/null | cut -c4-| sort -n | tail -n 1 | cut -f1 -d. )
cd ../std
MAXSTDVAL=$(ls std[[:digit:]]*.txt* 2>/dev/null | cut -c4-| sort -n | tail -n 1 | cut -f1 -d. )
cd ..
#$MyDialog --title "$ME-$Minor.$Revision: notify" --msgbox "$PLACE: RFC: $MAXVAL; BCP: $MAXBCPVAL; FYI: $MAXFYIVAL; STD: $MAXSTDVAL" 8 60
# Now, we check out the writeable dir's value
if [ "$WRITEABLE" ]; then
    OLDPLACE=$PLACE
    if [ "$PLACE" != "$WRITEABLE" ]; then
# Only change dir if we have to, and change back afterwards
        cd $WRITEABLE
        MAXWVAL=$(ls  rfc[[:digit:]]*.txt* 2>/dev/null | cut -c4-| sort -n | tail -n 1 | cut -f1 -d. )
        cd $OLDPLACE
    else
        MAXWVAL=$MAXVAL # might as well make it the same - but watch for bugs
    fi
# This test FAILS if either of MAXVAL or MAXWVAL are not defined. We have to wrap it.
    if [ ! -z "$MAXVAL" -o ! -z "$MAXWVAL" ]; then 
        if [ "$MAXWVAL" -gt "$MAXVAL" ]; then
# switch values
            MAXTVAL=$MAXVAL
            MAXVAL=$MAXWVAL
            MAXWVAL=$MAXTVAL
        fi
    fi # This wraps the MAXVAL|MAXWVAL test
fi

# Now we make sure it's not empty
# ZD: Meaningful variable names?
if [ "$MAXVAL" != "" ]; then
    if [ $MAXVAL -lt "1000" ]; then 
        MAXK=0
        if [ $MAXVAL -lt "100" ]; then 
            MAXH=0
            if [ $MAXVAL -lt "10" ]; then 
                MAXT=0
            else
                MAXT=$(echo $MAXVAL| cut -c1)
            fi
        else
            MAXH=$(echo $MAXVAL| cut -c1)
            MAXT=$(echo $MAXVAL| cut -c2)
        fi
    else
        MAXK=$(echo $MAXVAL| cut -c1)
        MAXH=$(echo $MAXVAL| cut -c2)
        MAXT=$(echo $MAXVAL| cut -c3)
    fi
# Hrm. None in global dir. Let's try localdir
elif [ "$MAXWVAL" != "" ]; then
    if [ $MAXWVAL -lt "1000" ]; then 
        MAXK=0
        if [ $MAXWVAL -lt "100" ]; then 
            MAXH=0
            if [ $MAXWVAL -lt "10" ]; then 
                MAXT=0
            else
                MAXT=$(echo $MAXWVAL| cut -c1)
            fi
        else
            MAXH=$(echo $MAXWVAL| cut -c1)
            MAXT=$(echo $MAXWVAL| cut -c2)
        fi
    else
        MAXK=$(echo $MAXWVAL| cut -c1)
        MAXH=$(echo $MAXWVAL| cut -c2)
        MAXT=$(echo $MAXWVAL| cut -c3)
    fi

else # uh oh, we have no rfcnnnn files here whatsoever, in either dir
###### bug #######
# This doesn't take into account if we have both a global AND 
# local writable dir... it picks the local if it's the last on the list
# and doesn't read the global - i.e. if we created a /home/user/rfc, then
# it tries to use that dir, even if the global is writable
###### bug #######
  REMOTEFILE=rfc1.txt
  Val=-get
# We'd better think about changing to $WRITEABLE first, else we'll get 
# the "I can't write to ..." message, which will only confuse people
  $MyDialog --title "$ME-$Minor.$Revision: query" --yesno "You haven't got any rfc files here. Shall I fetch some?" 7 40
  if [ "$?" = 0 ]; then
    if [ "$WRITEABLE" ]; then
      cd $WRITEABLE # we have to assume this exists, before changing to it.
    # REMOTEFILE=rfc1.txt, remember? LOL...
      FetchSingle
# We probably need to get some common files too...
      REMOTEFILE=rfc-index.txt
      FetchSingle
      REMOTEFILE=rfc-ref.txt
      FetchSingle
      REMOTEFILE=rfcxx00.txt
      FetchSingle
      MYLINES=12
      MyNotify "Now you have rfc1, you can now get further documents\n\
from $REMOTEPLACE \n\
from the program menu - see Help for more details."
    else # bitchmoan
      # We should be running this through ParseSwitch or FetchCore
      MYLINES=10
      MyError "I can't download to $PLACE\n\
You don't have permission to write to the directory."
    fi
  else
    exit 0  
  fi
fi
if [ "$1" = "" ]; then
        # Maybe we should pass through into a global menu?
    while [ "$noexit" = 1 ]; do
        # This sets $menulevel on entry
        TaskSelect
    done
else
    while [ "$1" ]; do
# I eventually plan to change this so that it asks for RFC, STD, FYI or BCP.
# It's my code. I'll write what I want... >(8-)
        menulevel=1 # there - that sets that.
        FeedQREST $@
#    echo "Q=$Q, REST=$REST, DEFEXT=$DEFEXT"
        ParseSwitch $Q $REST
        if [ $menulevel -gt 0 ]; then
            MenuSwitch=$1
#    if [ "$1" != "-menu" -a "$1" != "-prompt" ]; then
#      shift
#    fi
            case $MenuSwitch in
        # This won't handle multiple entries, i.e. -get 2345 2346 2348 2350
                -get|--get)
        # pop off two, but see comment above
                    shift 2 ;;
                -getrange|--getrange|-range|--range)
        # pop off three (-getrange from to), but see comment above
                    shift 3 ;;
                -menu|--menu|-prompt|--prompt|--front)
        # If we have -menu, keep cycling until we select <Cancel>
                    ;;
        # ! TODO: We have to change this, as it won't work for search terms that 
        #   are more than one word.
                -search|--search|--title|-title|--searchtitles|-searchtitles)
                    if [ "$2" ]; then
                        shift 2
                    fi
                    ;;
                -no|--forceget|--debug|--consoledialog) 
                    shift
                    ;;
        # Theoretically, we exit on a version
                -version|-v|--version)
                    exit
                    ;;
                *) # Anything else, we pop off the var, leaving the rest on the stack
                    shift ;;
            esac
        else
    # Okay, we've finished inside the menu, time to leave.
            exit
        fi
    done
    if [ "$menulevel" -gt 0 ]; then
      TaskSelect
    fi
fi

# ZD: Bye bye
